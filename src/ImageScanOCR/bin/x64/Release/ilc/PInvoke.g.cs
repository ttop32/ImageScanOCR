#define MCG_WINRT_SUPPORTED
using Mcg.System;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.WindowsRuntime;
using global::Windows.Foundation;
using global::Windows.Foundation.Collections;


// -----------------------------------------------------------------------------------------------------------
// 
// WARNING: THIS SOURCE FILE IS FOR 64-BIT BUILDS ONLY!
// 
// MCG GENERATED CODE
// 
// This C# source file is generated by MCG and is added into the application at compile time to support interop features.
// 
// It has three primary components:
// 
// 1. Public type definitions with interop implementation used by this application including WinRT & COM data structures and P/Invokes.
// 
// 2. The '__Interop' class containing marshaling code that acts as a bridge from managed code to native code.
// 
// 3. The 'McgNative' class containing marshaling code and native type definitions that call into native code and are called by native code.
// 
// -----------------------------------------------------------------------------------------------------------
// 
// warning CS0067: The event 'event' is never used
#pragma warning disable 67
// warning CS0169: The field 'field' is never used
#pragma warning disable 169
// warning CS0649: Field 'field' is never assigned to, and will always have its default value 0
#pragma warning disable 414
// warning CS0414: The private field 'field' is assigned but its value is never used
#pragma warning disable 649
// warning CS1591: Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// warning CS0108 'member1' hides inherited member 'member2'. Use the new keyword if hiding was intended.
#pragma warning disable 108
// warning CS0114 'member1' hides inherited member 'member2'.  To make the current method override that implementation, add the override keyword. Otherwise add the new keyword.
#pragma warning disable 114
// warning CS0659 'type' overrides Object.Equals but does not override GetHashCode.
#pragma warning disable 659
// warning CS0465 Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?
#pragma warning disable 465
// warning CS0028 'function declaration' has the wrong signature to be an entry point
#pragma warning disable 28
// warning CS0162 Unreachable code Detected
#pragma warning disable 162
// warning CS0628 new protected member declared in sealed class
#pragma warning disable 628

namespace __Interop
{
	/// <summary>
	/// P/Invoke class for module '[MRT]'
	/// </summary>
	public unsafe static partial class _MRT_
	{
		// Signature, RhpGetFuncEvalParameterBufferSize, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpGetFuncEvalParameterBufferSize")]
		public static uint RhpGetFuncEvalParameterBufferSize()
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpGetFuncEvalParameterBufferSize();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhpGetFuncEvalMode, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpGetFuncEvalMode")]
		public static uint RhpGetFuncEvalMode()
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpGetFuncEvalMode();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhpRecordDebuggeeInitiatedHandle, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpRecordDebuggeeInitiatedHandle")]
		public static uint RhpRecordDebuggeeInitiatedHandle(void* objectHandle)
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpRecordDebuggeeInitiatedHandle(((void*)objectHandle));
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhpVerifyDebuggerCleanup, [fwd] [return] [EETypeRva:0x00041F6C] void__void, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpVerifyDebuggerCleanup")]
		public static void RhpVerifyDebuggerCleanup()
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhpVerifyDebuggerCleanup();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, RhpGetCurrentThread, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpGetCurrentThread")]
		public static global::System.IntPtr RhpGetCurrentThread()
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpGetCurrentThread();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhWaitForPendingFinalizers, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhWaitForPendingFinalizers")]
		public static void RhWaitForPendingFinalizers(int allowReentrantWait)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhWaitForPendingFinalizers(allowReentrantWait);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, _RhYield, [fwd] [return] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "_RhYield")]
		public static int _RhYield()
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes._RhYield();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhFlushProcessWriteBuffers, [fwd] [return] [EETypeRva:0x00041F6C] void__void, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhFlushProcessWriteBuffers")]
		public static void RhFlushProcessWriteBuffers()
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhFlushProcessWriteBuffers();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, RhCompatibleReentrantWaitAny, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr___ptr__w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhCompatibleReentrantWaitAny")]
		public static int RhCompatibleReentrantWaitAny(
					int alertable, 
					int timeout, 
					int count, 
					global::System.IntPtr* handles)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhCompatibleReentrantWaitAny(
								alertable, 
								timeout, 
								count, 
								((global::System.IntPtr*)handles)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhCallDescrWorkerNative, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhCallDescrWorkerNative")]
		public static void RhCallDescrWorkerNative(global::System.IntPtr callDescr)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhCallDescrWorkerNative(callDescr);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, _ecvt_s, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] double__double, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int___ptrint *, [fwd] [in] [EETypeRva:0x000419B0] int___ptrint *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "_ecvt_s")]
		public static void _ecvt_s(
					byte* buffer, 
					int sizeInBytes, 
					double value, 
					int count, 
					int* dec, 
					int* sign)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes._ecvt_s(
								((byte*)buffer), 
								sizeInBytes, 
								value, 
								count, 
								((int*)dec), 
								((int*)sign)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, memmove, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] ulong__unsigned __int64, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "memmove")]
		public static void memmove(
					byte* dmem, 
					byte* smem, 
					ulong size)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.memmove(
								((byte*)dmem), 
								((byte*)smem), 
								size
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, memset, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] ulong__unsigned __int64, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "memset")]
		public static void memset(
					byte* mem, 
					int value, 
					ulong size)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.memset(
								((byte*)mem), 
								value, 
								size
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module '*'
	/// </summary>
	public unsafe static partial class _
	{
		// Signature, CallingConventionConverter_GetStubs, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.TypeLoader, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.Runtime.TypeLoader.CallConverterThunk", "CallingConventionConverter_GetStubs")]
		public static void CallingConventionConverter_GetStubs(
					out global::System.IntPtr returnVoidStub, 
					out global::System.IntPtr returnIntegerStub, 
					out global::System.IntPtr commonStub)
		{
			// Marshalling
			fixed (global::System.IntPtr* pinned_returnVoidStub = &(returnVoidStub))
				fixed (global::System.IntPtr* pinned_returnIntegerStub = &(returnIntegerStub))
					fixed (global::System.IntPtr* pinned_commonStub = &(commonStub))
					{
						// Call to native method
						global::__Interop.__PInvokes.CallingConventionConverter_GetStubs(
											pinned_returnVoidStub, 
											pinned_returnIntegerStub, 
											pinned_commonStub
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					}
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-winrt-string-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_winrt_string_l1_1_0_dll
	{
		// Signature, WindowsCreateStringReference, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] System_Runtime_InteropServices_HSTRING_HEADER__System_Private_Interop___ptrSystem_Runtime_InteropServices__HSTRING_HEADER__System_Private_Interop *, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore", "WindowsCreateStringReference")]
		public static int WindowsCreateStringReference(
					char* sourceString, 
					uint length, 
					global::System_Runtime_InteropServices.HSTRING_HEADER__System_Private_Interop* phstringHeader, 
					void* hstring)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_winrt_string_l1_1_0_dll_PInvokes.WindowsCreateStringReference(
								((ushort*)sourceString), 
								length, 
								((global::System_Runtime_InteropServices.HSTRING_HEADER__System_Private_Interop*)phstringHeader), 
								((void*)hstring)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-errorhandling-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_errorhandling_l1_1_0_dll
	{
		// Signature, GetLastError, [fwd] [return] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "GetLastError")]
		public static int GetLastError()
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_errorhandling_l1_1_0_dll_PInvokes.GetLastError();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, SetLastError, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "SetLastError")]
		public static void SetLastError(uint dwErrCode)
		{
			// Marshalling
			// Call to native method
			global::__Interop.api_ms_win_core_errorhandling_l1_1_0_dll_PInvokes.SetLastError(dwErrCode);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-winrt-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_winrt_l1_1_0_dll
	{
		// Signature, RoInitialize, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "RoInitialize")]
		public static int RoInitialize(uint initType)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_winrt_l1_1_0_dll_PInvokes.RoInitialize(initType);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-localization-l1-2-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_localization_l1_2_0_dll
	{
		// Signature, IsValidLocaleName, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "IsValidLocaleName")]
		public static int IsValidLocaleName(char* lpLocaleName)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.IsValidLocaleName(((ushort*)lpLocaleName));
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, ResolveLocaleName, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "ResolveLocaleName")]
		public static int ResolveLocaleName(
					char* lpNameToResolve, 
					char* lpLocaleName, 
					int cchLocaleName)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.ResolveLocaleName(
								((ushort*)lpNameToResolve), 
								((ushort*)lpLocaleName), 
								cchLocaleName
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'crypt32.dll'
	/// </summary>
	public unsafe static partial class crypt32_dll
	{
		// Signature, CertDuplicateCertificateContext, [fwd] [return] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertDuplicateCertificateContext")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates CertDuplicateCertificateContext(global::System.IntPtr pCertContext)
		{
			// Setup
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertDuplicateCertificateContext(pCertContext);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, CertGetCertificateContextProperty, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertContextPropId__System_Security_Cryptography_X509Certificates__CertContextPropId__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] Internal_Cryptography_Pal_Native_CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetCertificateContextProperty")]
		public static bool CertGetCertificateContextProperty(
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					out global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			pCertContext.DangerousAddRef(ref addRefed);
			fixed (global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pinned_pvData = &(pvData))
				fixed (int* pinned_pcbData = &(pcbData))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetCertificateContextProperty(
										pCertContext.DangerousGetHandle(), 
										dwPropId, 
										pinned_pvData, 
										pinned_pcbData
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				pCertContext.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptQueryObject, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertQueryObjectType__System_Security_Cryptography_X509Certificates__CertQueryObjectType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates__ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates__ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_ContentType__System_Security_Cryptography_X509Certificates__ContentType__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_FormatType__System_Security_Cryptography_X509Certificates__FormatType__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptQueryObject")]
		public static bool CryptQueryObject(
					global::Internal_Cryptography_Pal_Native.CertQueryObjectType__System_Security_Cryptography_X509Certificates dwObjectType, 
					void* pvObject, 
					global::Internal_Cryptography_Pal_Native.ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedContentTypeFlags, 
					global::Internal_Cryptography_Pal_Native.ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedFormatTypeFlags, 
					int dwFlags, 
					out global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates pdwMsgAndCertEncodingType, 
					out global::Internal_Cryptography_Pal_Native.ContentType__System_Security_Cryptography_X509Certificates pdwContentType, 
					out global::Internal_Cryptography_Pal_Native.FormatType__System_Security_Cryptography_X509Certificates pdwFormatType, 
					out global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates phCertStore, 
					out global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates phMsg, 
					out global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates ppvContext)
		{
			// Setup
			global::System.IntPtr unsafe_phCertStore;
			global::System.IntPtr unsafe_phMsg;
			global::System.IntPtr unsafe_ppvContext;
			int unsafe___value;
			// Marshalling
			fixed (global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates* pinned_pdwMsgAndCertEncodingType = &(pdwMsgAndCertEncodingType))
				fixed (global::Internal_Cryptography_Pal_Native.ContentType__System_Security_Cryptography_X509Certificates* pinned_pdwContentType = &(pdwContentType))
					fixed (global::Internal_Cryptography_Pal_Native.FormatType__System_Security_Cryptography_X509Certificates* pinned_pdwFormatType = &(pdwFormatType))
					{
						phCertStore = new global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates();
						unsafe_phCertStore = phCertStore.DangerousGetHandle();
						phMsg = new global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates();
						unsafe_phMsg = phMsg.DangerousGetHandle();
						ppvContext = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
						unsafe_ppvContext = ppvContext.DangerousGetHandle();
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptQueryObject(
											dwObjectType, 
											((void*)pvObject), 
											dwExpectedContentTypeFlags, 
											dwExpectedFormatTypeFlags, 
											dwFlags, 
											pinned_pdwMsgAndCertEncodingType, 
											pinned_pdwContentType, 
											pinned_pdwFormatType, 
											&(unsafe_phCertStore), 
											&(unsafe_phMsg), 
											&(unsafe_ppvContext)
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
						global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
											ppvContext, 
											unsafe_ppvContext
										);
						global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
											phMsg, 
											unsafe_phMsg
										);
						global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
											phCertStore, 
											unsafe_phCertStore
										);
					}
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertDuplicateCertificateContextWithKeyContainerDeletion, [fwd] [return] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertDuplicateCertificateContextWithKeyContainerDeletion")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates CertDuplicateCertificateContextWithKeyContainerDeletion(global::System.IntPtr pCertContext)
		{
			// Setup
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertDuplicateCertificateContextWithKeyContainerDeletion(pCertContext);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, CertFreeCertificateContext, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertFreeCertificateContext")]
		public static bool CertFreeCertificateContext(global::System.IntPtr pCertContext)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertFreeCertificateContext(pCertContext);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptMsgGetParam, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CryptMessageParameterType__System_Security_Cryptography_X509Certificates__CryptMessageParameterType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptMsgGetParam")]
		public static bool CryptMsgGetParam(
					global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates hCryptMsg, 
					global::Internal_Cryptography_Pal_Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					out int pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hCryptMsg.DangerousAddRef(ref addRefed);
			fixed (int* pinned_pvData = &(pvData))
				fixed (int* pinned_pcbData = &(pcbData))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptMsgGetParam(
										hCryptMsg.DangerousGetHandle(), 
										dwParamType, 
										dwIndex, 
										pinned_pvData, 
										pinned_pcbData
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				hCryptMsg.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptMsgGetParam__0, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CryptMessageParameterType__System_Security_Cryptography_X509Certificates__CryptMessageParameterType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptMsgGetParam")]
		public static bool CryptMsgGetParam__0(
					global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates hCryptMsg, 
					global::Internal_Cryptography_Pal_Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					byte* pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hCryptMsg.DangerousAddRef(ref addRefed);
			fixed (int* pinned_pcbData = &(pcbData))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptMsgGetParam__0(
									hCryptMsg.DangerousGetHandle(), 
									dwParamType, 
									dwIndex, 
									((byte*)pvData), 
									pinned_pcbData
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				hCryptMsg.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, PFXImportCertStore, [fwd] [return] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] Internal_Cryptography_Pal_Native_CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafePasswordHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_PfxCertStoreFlags__System_Security_Cryptography_X509Certificates__PfxCertStoreFlags__System_Security_Cryptography_X509Certificates, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "PFXImportCertStore")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates PFXImportCertStore(
					ref global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates pPFX, 
					global::Microsoft.Win32.SafeHandles.SafePasswordHandle__System_Security_Cryptography_X509Certificates password, 
					global::Internal_Cryptography_Pal_Native.PfxCertStoreFlags__System_Security_Cryptography_X509Certificates dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			fixed (global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pinned_pPFX = &(pPFX))
			{
				password.DangerousAddRef(ref addRefed);
				__value = new global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.PFXImportCertStore(
									pinned_pPFX, 
									password.DangerousGetHandle(), 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									__value, 
									unsafe___value
								);
				if (addRefed)
					password.DangerousRelease();
			}
			// Return
			return __value;
		}

		// Signature, CryptFindOIDInfo, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] __Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Encoding__Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Encoding, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Security_Cryptography_OidGroup__System_Security_Cryptography_Encoding__OidGroup__System_Security_Cryptography_Encoding, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Encoding, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Crypt32", "CryptFindOIDInfo")]
		public static global::System.IntPtr CryptFindOIDInfo(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Encoding dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptFindOIDInfo(
								dwKeyType, 
								pvKey, 
								group
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, CertGetCertificateContextProperty__0, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertContextPropId__System_Security_Cryptography_X509Certificates__CertContextPropId__System_Security_Cryptography_X509Certificates, [fwd] [out] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetCertificateContextProperty")]
		public static bool CertGetCertificateContextProperty__0(
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					byte[] pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pvData;
			int unsafe___value;
			// Marshalling
			pCertContext.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pvData = ((pvData != null 
						&& pvData.Length == 0) ? new byte[1] : pvData))
			{
				unsafe_pvData = (byte*)pinned_pvData;
				fixed (int* pinned_pcbData = &(pcbData))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetCertificateContextProperty__0(
										pCertContext.DangerousGetHandle(), 
										dwPropId, 
										unsafe_pvData, 
										pinned_pcbData
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			if (addRefed)
				pCertContext.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertCloseStore, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertCloseStore")]
		public static bool CertCloseStore(
					global::System.IntPtr hCertStore, 
					int dwFlags)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertCloseStore(
								hCertStore, 
								dwFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptMsgClose, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptMsgClose")]
		public static bool CryptMsgClose(global::System.IntPtr hCryptMsg)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptMsgClose(hCryptMsg);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertFindCertificateInStore, [fwd] [return] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertFindFlags__System_Security_Cryptography_X509Certificates__CertFindFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertFindType__System_Security_Cryptography_X509Certificates__CertFindType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [EETypeRva:0x000419B0] Internal_Cryptography_Pal_Native_CERT_CONTEXT__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_CONTEXT__System_Security_Cryptography_X509Certificates *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertFindCertificateInStore")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates CertFindCertificateInStore(
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hCertStore, 
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CertFindFlags__System_Security_Cryptography_X509Certificates dwFindFlags, 
					global::Internal_Cryptography_Pal_Native.CertFindType__System_Security_Cryptography_X509Certificates dwFindType, 
					void* pvFindPara, 
					global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext)
		{
			// Setup
			bool addRefed = false;
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			hCertStore.DangerousAddRef(ref addRefed);
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertFindCertificateInStore(
								hCertStore.DangerousGetHandle(), 
								dwCertEncodingType, 
								dwFindFlags, 
								dwFindType, 
								((void*)pvFindPara), 
								((global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates*)pPrevCertContext)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			if (addRefed)
				hCertStore.DangerousRelease();
			// Return
			return __value;
		}

		// Signature, CertEnumCertificatesInStore, [fwd] [return] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x000419B0] Internal_Cryptography_Pal_Native_CERT_CONTEXT__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_CONTEXT__System_Security_Cryptography_X509Certificates *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertEnumCertificatesInStore")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates CertEnumCertificatesInStore(
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hCertStore, 
					global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext)
		{
			// Setup
			bool addRefed = false;
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			hCertStore.DangerousAddRef(ref addRefed);
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertEnumCertificatesInStore(
								hCertStore.DangerousGetHandle(), 
								((global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates*)pPrevCertContext)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			if (addRefed)
				hCertStore.DangerousRelease();
			// Return
			return __value;
		}

		// Signature, CertGetNameString, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertNameType__System_Security_Cryptography_X509Certificates__CertNameType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertNameFlags__System_Security_Cryptography_X509Certificates__CertNameFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates__CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates, [fwd] [out] [EETypeRva:0x00041CF4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetNameString")]
		public static int CertGetNameString(
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertNameType__System_Security_Cryptography_X509Certificates dwType, 
					global::Internal_Cryptography_Pal_Native.CertNameFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					ref global::Internal_Cryptography_Pal_Native.CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates pvPara, 
					global::System.Text.StringBuilder pszNameString, 
					int cchNameString)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszNameString = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				pCertContext.DangerousAddRef(ref addRefed);
				fixed (global::Internal_Cryptography_Pal_Native.CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates* pinned_pvPara = &(pvPara))
				{
					if (pszNameString == null)
						unsafe_pszNameString = null;
					else
					{
						unsafe_pszNameString = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(pszNameString.Capacity * 2 
											+ 2)));
						if (unsafe_pszNameString == null)
							throw new global::System.OutOfMemoryException();
					}
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetNameString(
										pCertContext.DangerousGetHandle(), 
										dwType, 
										dwFlags, 
										pinned_pvPara, 
										unsafe_pszNameString, 
										cchNameString
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					if (pszNameString != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_pszNameString, 
											pszNameString
										);
				}
				if (addRefed)
					pCertContext.DangerousRelease();
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_pszNameString != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pszNameString);
			}
		}

		// Signature, CertGetNameString__0, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertNameType__System_Security_Cryptography_X509Certificates__CertNameType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertNameFlags__System_Security_Cryptography_X509Certificates__CertNameFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertNameStringType__System_Security_Cryptography_X509Certificates__CertNameStringType__System_Security_Cryptography_X509Certificates, [fwd] [out] [EETypeRva:0x00041CF4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetNameString")]
		public static int CertGetNameString__0(
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertNameType__System_Security_Cryptography_X509Certificates dwType, 
					global::Internal_Cryptography_Pal_Native.CertNameFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					ref global::Internal_Cryptography_Pal_Native.CertNameStringType__System_Security_Cryptography_X509Certificates pvTypePara, 
					global::System.Text.StringBuilder pszNameString, 
					int cchNameString)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszNameString = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				pCertContext.DangerousAddRef(ref addRefed);
				fixed (global::Internal_Cryptography_Pal_Native.CertNameStringType__System_Security_Cryptography_X509Certificates* pinned_pvTypePara = &(pvTypePara))
				{
					if (pszNameString == null)
						unsafe_pszNameString = null;
					else
					{
						unsafe_pszNameString = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(pszNameString.Capacity * 2 
											+ 2)));
						if (unsafe_pszNameString == null)
							throw new global::System.OutOfMemoryException();
					}
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetNameString__0(
										pCertContext.DangerousGetHandle(), 
										dwType, 
										dwFlags, 
										pinned_pvTypePara, 
										unsafe_pszNameString, 
										cchNameString
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					if (pszNameString != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_pszNameString, 
											pszNameString
										);
				}
				if (addRefed)
					pCertContext.DangerousRelease();
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_pszNameString != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pszNameString);
			}
		}

		// Signature, CryptFindOIDInfo__0, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] __Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_X509Certificates__Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Security_Cryptography_OidGroup__System_Security_Cryptography_Encoding__OidGroup__System_Security_Cryptography_Encoding, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+Crypt32", "CryptFindOIDInfo")]
		public static global::System.IntPtr CryptFindOIDInfo__0(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_X509Certificates dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptFindOIDInfo__0(
								dwKeyType, 
								pvKey, 
								group
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, CertGetCertificateChain, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x000419B0] Internal_Cryptography_Pal_Native_FILETIME__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__FILETIME__System_Security_Cryptography_X509Certificates *, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] Internal_Cryptography_Pal_Native_CERT_CHAIN_PARA__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CERT_CHAIN_PARA__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertChainFlags__System_Security_Cryptography_X509Certificates__CertChainFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeX509ChainHandle__System_Security_Cryptography_X509Certificates____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetCertificateChain")]
		public static bool CertGetCertificateChain(
					global::System.IntPtr hChainEngine, 
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates* pTime, 
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hStore, 
					ref global::Internal_Cryptography_Pal_Native.CERT_CHAIN_PARA__System_Security_Cryptography_X509Certificates pChainPara, 
					global::Internal_Cryptography_Pal_Native.CertChainFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::System.IntPtr pvReserved, 
					out global::Microsoft.Win32.SafeHandles.SafeX509ChainHandle__System_Security_Cryptography_X509Certificates ppChainContext)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			global::System.IntPtr unsafe_ppChainContext;
			int unsafe___value;
			// Marshalling
			pCertContext.DangerousAddRef(ref addRefed);
			hStore.DangerousAddRef(ref addRefed_1);
			fixed (global::Internal_Cryptography_Pal_Native.CERT_CHAIN_PARA__System_Security_Cryptography_X509Certificates* pinned_pChainPara = &(pChainPara))
			{
				ppChainContext = new global::Microsoft.Win32.SafeHandles.SafeX509ChainHandle__System_Security_Cryptography_X509Certificates();
				unsafe_ppChainContext = ppChainContext.DangerousGetHandle();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetCertificateChain(
									hChainEngine, 
									pCertContext.DangerousGetHandle(), 
									((global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates*)pTime), 
									hStore.DangerousGetHandle(), 
									pinned_pChainPara, 
									dwFlags, 
									pvReserved, 
									&(unsafe_ppChainContext)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									ppChainContext, 
									unsafe_ppChainContext
								);
			}
			if (addRefed_1)
				hStore.DangerousRelease();
			if (addRefed)
				pCertContext.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertVerifyCertificateChainPolicy, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeX509ChainHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] Internal_Cryptography_Pal_Native_CERT_CHAIN_POLICY_PARA__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CERT_CHAIN_POLICY_PARA__System_Security_Cryptography_X509Certificates, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] Internal_Cryptography_Pal_Native_CERT_CHAIN_POLICY_STATUS__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CERT_CHAIN_POLICY_STATUS__System_Security_Cryptography_X509Certificates, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertVerifyCertificateChainPolicy")]
		public static bool CertVerifyCertificateChainPolicy(
					global::System.IntPtr pszPolicyOID, 
					global::Microsoft.Win32.SafeHandles.SafeX509ChainHandle__System_Security_Cryptography_X509Certificates pChainContext, 
					ref global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_PARA__System_Security_Cryptography_X509Certificates pPolicyPara, 
					ref global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_STATUS__System_Security_Cryptography_X509Certificates pPolicyStatus)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			pChainContext.DangerousAddRef(ref addRefed);
			fixed (global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_PARA__System_Security_Cryptography_X509Certificates* pinned_pPolicyPara = &(pPolicyPara))
				fixed (global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_STATUS__System_Security_Cryptography_X509Certificates* pinned_pPolicyStatus = &(pPolicyStatus))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertVerifyCertificateChainPolicy(
										pszPolicyOID, 
										pChainContext.DangerousGetHandle(), 
										pinned_pPolicyPara, 
										pinned_pPolicyStatus
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				pChainContext.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertNameToStr, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] Internal_Cryptography_Pal_Native_CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates__CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [out] [EETypeRva:0x00041CF4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertNameToStr")]
		public static int CertNameToStr(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					ref global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates pName, 
					global::Internal_Cryptography_Pal_Native.CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates dwStrType, 
					global::System.Text.StringBuilder psz, 
					int csz)
		{
			// Setup
			ushort* unsafe_psz = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				fixed (global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pinned_pName = &(pName))
				{
					if (psz == null)
						unsafe_psz = null;
					else
					{
						unsafe_psz = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(psz.Capacity * 2 
											+ 2)));
						if (unsafe_psz == null)
							throw new global::System.OutOfMemoryException();
					}
					if (unsafe_psz != null)
						global::System.Runtime.InteropServices.McgMarshal.StringBuilderToUnicodeString(
											psz, 
											unsafe_psz
										);
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertNameToStr(
										dwCertEncodingType, 
										pinned_pName, 
										dwStrType, 
										unsafe_psz, 
										csz
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					if (psz != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_psz, 
											psz
										);
				}
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_psz != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_psz);
			}
		}

		// Signature, CryptFormatObject, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041C30] string__unsigned char *, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [EETypeRva:0x00041CF4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Encoding, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.Cng+Interop", "CryptFormatObject")]
		public static bool CryptFormatObject(
					int dwCertEncodingType, 
					int dwFormatType, 
					int dwFormatStrType, 
					global::System.IntPtr pFormatStruct, 
					string lpszStructType, 
					byte[] pbEncoded, 
					int cbEncoded, 
					global::System.Text.StringBuilder pbFormat, 
					ref int pcbFormat)
		{
			// Setup
			byte* unsafe_lpszStructType = default(byte*);
			byte* unsafe_pbEncoded;
			ushort* unsafe_pbFormat = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				unsafe_lpszStructType = global::System.Runtime.InteropServices.McgMarshal.StringToAnsiString(lpszStructType, false, false);
				fixed (byte* pinned_pbEncoded = ((pbEncoded != null 
							&& pbEncoded.Length == 0) ? new byte[1] : pbEncoded))
				{
					unsafe_pbEncoded = (byte*)pinned_pbEncoded;
					if (pbFormat == null)
						unsafe_pbFormat = null;
					else
					{
						unsafe_pbFormat = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(pbFormat.Capacity * 2 
											+ 2)));
						if (unsafe_pbFormat == null)
							throw new global::System.OutOfMemoryException();
					}
					fixed (int* pinned_pcbFormat = &(pcbFormat))
					{
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptFormatObject(
											dwCertEncodingType, 
											dwFormatType, 
											dwFormatStrType, 
											pFormatStruct, 
											unsafe_lpszStructType, 
											unsafe_pbEncoded, 
											cbEncoded, 
											unsafe_pbFormat, 
											pinned_pcbFormat
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
					if (pbFormat != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_pbFormat, 
											pbFormat
										);
				}
				// Return
				return unsafe___value != 0;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_lpszStructType);
				if (unsafe_pbFormat != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pbFormat);
			}
		}

		// Signature, CertControlStore, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertControlStoreFlags__System_Security_Cryptography_X509Certificates__CertControlStoreFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertControlStoreType__System_Security_Cryptography_X509Certificates__CertControlStoreType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertControlStore")]
		public static bool CertControlStore(
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hCertStore, 
					global::Internal_Cryptography_Pal_Native.CertControlStoreFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::Internal_Cryptography_Pal_Native.CertControlStoreType__System_Security_Cryptography_X509Certificates dwControlType, 
					global::System.IntPtr pvCtrlPara)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hCertStore.DangerousAddRef(ref addRefed);
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertControlStore(
								hCertStore.DangerousGetHandle(), 
								dwFlags, 
								dwControlType, 
								pvCtrlPara
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hCertStore.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertAddCertificateLinkToStore, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertStoreAddDisposition__System_Security_Cryptography_X509Certificates__CertStoreAddDisposition__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertAddCertificateLinkToStore")]
		public static bool CertAddCertificateLinkToStore(
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hCertStore, 
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertStoreAddDisposition__System_Security_Cryptography_X509Certificates dwAddDisposition, 
					global::System.IntPtr ppStoreContext)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			int unsafe___value;
			// Marshalling
			hCertStore.DangerousAddRef(ref addRefed);
			pCertContext.DangerousAddRef(ref addRefed_1);
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertAddCertificateLinkToStore(
								hCertStore.DangerousGetHandle(), 
								pCertContext.DangerousGetHandle(), 
								dwAddDisposition, 
								ppStoreContext
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed_1)
				pCertContext.DangerousRelease();
			if (addRefed)
				hCertStore.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptFormatObject__0, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_FormatObjectType__System_Security_Cryptography_X509Certificates__FormatObjectType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_FormatObjectStringType__System_Security_Cryptography_X509Certificates__FormatObjectStringType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [EETypeRva:0x00041CF4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptFormatObject")]
		public static bool CryptFormatObject__0(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.FormatObjectType__System_Security_Cryptography_X509Certificates dwFormatType, 
					global::Internal_Cryptography_Pal_Native.FormatObjectStringType__System_Security_Cryptography_X509Certificates dwFormatStrType, 
					global::System.IntPtr pFormatStruct, 
					global::System.IntPtr lpszStructType, 
					byte[] pbEncoded, 
					int cbEncoded, 
					global::System.Text.StringBuilder pbFormat, 
					ref int pcbFormat)
		{
			// Setup
			byte* unsafe_pbEncoded;
			ushort* unsafe_pbFormat = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				fixed (byte* pinned_pbEncoded = ((pbEncoded != null 
							&& pbEncoded.Length == 0) ? new byte[1] : pbEncoded))
				{
					unsafe_pbEncoded = (byte*)pinned_pbEncoded;
					if (pbFormat == null)
						unsafe_pbFormat = null;
					else
					{
						unsafe_pbFormat = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(pbFormat.Capacity * 2 
											+ 2)));
						if (unsafe_pbFormat == null)
							throw new global::System.OutOfMemoryException();
					}
					fixed (int* pinned_pcbFormat = &(pcbFormat))
					{
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptFormatObject__0(
											dwCertEncodingType, 
											dwFormatType, 
											dwFormatStrType, 
											pFormatStruct, 
											lpszStructType, 
											unsafe_pbEncoded, 
											cbEncoded, 
											unsafe_pbFormat, 
											pinned_pcbFormat
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
					if (pbFormat != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_pbFormat, 
											pbFormat
										);
				}
				// Return
				return unsafe___value != 0;
			}
			finally
			{
				// Cleanup
				if (unsafe_pbFormat != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pbFormat);
			}
		}

		// Signature, CertOpenStore, [fwd] [return] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertStoreFlags__System_Security_Cryptography_X509Certificates__CertStoreFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertOpenStore")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates CertOpenStore(
					global::System.IntPtr lpszStoreProvider, 
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwMsgAndCertEncodingType, 
					global::System.IntPtr hCryptProv, 
					global::Internal_Cryptography_Pal_Native.CertStoreFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					string pvPara)
		{
			// Setup
			ushort* unsafe_pvPara = default(ushort*);
			global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			fixed (char* pinned_pvPara = pvPara)
			{
				unsafe_pvPara = (ushort*)pinned_pvPara;
				__value = new global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertOpenStore(
									lpszStoreProvider, 
									dwMsgAndCertEncodingType, 
									hCryptProv, 
									dwFlags, 
									unsafe_pvPara
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									__value, 
									unsafe___value
								);
			}
			// Return
			return __value;
		}

		// Signature, CryptImportPublicKeyInfoEx2, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] Internal_Cryptography_Pal_Native_CERT_PUBLIC_KEY_INFO__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_PUBLIC_KEY_INFO__System_Security_Cryptography_X509Certificates *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeBCryptKeyHandle__System_Security_Cryptography_X509Certificates____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptImportPublicKeyInfoEx2")]
		public static bool CryptImportPublicKeyInfoEx2(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CERT_PUBLIC_KEY_INFO__System_Security_Cryptography_X509Certificates* pInfo, 
					int dwFlags, 
					void* pvAuxInfo, 
					out global::Microsoft.Win32.SafeHandles.SafeBCryptKeyHandle__System_Security_Cryptography_X509Certificates phKey)
		{
			// Setup
			global::System.IntPtr unsafe_phKey;
			int unsafe___value;
			// Marshalling
			phKey = new global::Microsoft.Win32.SafeHandles.SafeBCryptKeyHandle__System_Security_Cryptography_X509Certificates();
			unsafe_phKey = phKey.DangerousGetHandle();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptImportPublicKeyInfoEx2(
								dwCertEncodingType, 
								((global::Internal_Cryptography_Pal_Native.CERT_PUBLIC_KEY_INFO__System_Security_Cryptography_X509Certificates*)pInfo), 
								dwFlags, 
								((void*)pvAuxInfo), 
								&(unsafe_phKey)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phKey, 
								unsafe_phKey
							);
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptDecodeObject, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates__CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates, [fwd] [out] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptDecodeObject")]
		public static bool CryptDecodeObject(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::System.IntPtr lpszStructType, 
					byte[] pbEncoded, 
					int cbEncoded, 
					global::Internal_Cryptography_Pal_Native.CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					byte[] pvStructInfo, 
					ref int pcbStructInfo)
		{
			// Setup
			byte* unsafe_pbEncoded;
			byte* unsafe_pvStructInfo;
			int unsafe___value;
			// Marshalling
			fixed (byte* pinned_pbEncoded = ((pbEncoded != null 
						&& pbEncoded.Length == 0) ? new byte[1] : pbEncoded))
			{
				unsafe_pbEncoded = (byte*)pinned_pbEncoded;
				fixed (byte* pinned_pvStructInfo = ((pvStructInfo != null 
							&& pvStructInfo.Length == 0) ? new byte[1] : pvStructInfo))
				{
					unsafe_pvStructInfo = (byte*)pinned_pvStructInfo;
					fixed (int* pinned_pcbStructInfo = &(pcbStructInfo))
					{
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptDecodeObject(
											dwCertEncodingType, 
											lpszStructType, 
											unsafe_pbEncoded, 
											cbEncoded, 
											dwFlags, 
											unsafe_pvStructInfo, 
											pinned_pcbStructInfo
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
				}
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertFreeCertificateChain, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertFreeCertificateChain")]
		public static void CertFreeCertificateChain(global::System.IntPtr pChainContext)
		{
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			global::__Interop.crypt32_dll_PInvokes.CertFreeCertificateChain(pChainContext);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
		}

		// Signature, CertFindExtension, [fwd] [return] [EETypeRva:0x000419B0] Internal_Cryptography_Pal_Native_CERT_EXTENSION__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_EXTENSION__System_Security_Cryptography_X509Certificates *, [fwd] [in] [EETypeRva:0x00041C30] string__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] Internal_Cryptography_Pal_Native_CERT_EXTENSION__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_EXTENSION__System_Security_Cryptography_X509Certificates *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertFindExtension")]
		public static global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates* CertFindExtension(
					string pszObjId, 
					int cExtensions, 
					global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates* rgExtensions)
		{
			// Setup
			byte* unsafe_pszObjId = default(byte*);
			global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates* unsafe___value;
			try
			{
				// Marshalling
				unsafe_pszObjId = global::System.Runtime.InteropServices.McgMarshal.StringToAnsiString(pszObjId, true, false);
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = (global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates*)global::__Interop.crypt32_dll_PInvokes.CertFindExtension(
									unsafe_pszObjId, 
									cExtensions, 
									((global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates*)rgExtensions)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				// Return
				return (global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates*)unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pszObjId);
			}
		}

		// Signature, CertGetValidUsages, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [out] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetValidUsages")]
		public static bool CertGetValidUsages(
					int cCerts, 
					ref global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates rghCerts, 
					out int cNumOIDs, 
					void* rghOIDs, 
					ref int pcbOIDs)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_rghCerts;
			int unsafe___value;
			// Marshalling
			rghCerts.DangerousAddRef(ref addRefed);
			unsafe_rghCerts = rghCerts.DangerousGetHandle();
			fixed (int* pinned_cNumOIDs = &(cNumOIDs))
				fixed (int* pinned_pcbOIDs = &(pcbOIDs))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetValidUsages(
										cCerts, 
										&(unsafe_rghCerts), 
										pinned_cNumOIDs, 
										((void*)rghOIDs), 
										pinned_pcbOIDs
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				rghCerts.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertGetIntendedKeyUsage, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] Internal_Cryptography_Pal_Native_CERT_INFO__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_INFO__System_Security_Cryptography_X509Certificates *, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D60] System_Security_Cryptography_X509Certificates_X509KeyUsageFlags__System_Security_Cryptography_X509Certificates__X509KeyUsageFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetIntendedKeyUsage")]
		public static bool CertGetIntendedKeyUsage(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates* pCertInfo, 
					out global::System_Security_Cryptography_X509Certificates.X509KeyUsageFlags__System_Security_Cryptography_X509Certificates pbKeyUsage, 
					int cbKeyUsage)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::System_Security_Cryptography_X509Certificates.X509KeyUsageFlags__System_Security_Cryptography_X509Certificates* pinned_pbKeyUsage = &(pbKeyUsage))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetIntendedKeyUsage(
									dwCertEncodingType, 
									((global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates*)pCertInfo), 
									pinned_pbKeyUsage, 
									cbKeyUsage
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptDecodeObjectPointer, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates__CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates, [fwd] [out] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptDecodeObjectPointer")]
		public static bool CryptDecodeObjectPointer(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::System.IntPtr lpszStructType, 
					byte[] pbEncoded, 
					int cbEncoded, 
					global::Internal_Cryptography_Pal_Native.CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					void* pvStructInfo, 
					ref int pcbStructInfo)
		{
			// Setup
			byte* unsafe_pbEncoded;
			int unsafe___value;
			// Marshalling
			fixed (byte* pinned_pbEncoded = ((pbEncoded != null 
						&& pbEncoded.Length == 0) ? new byte[1] : pbEncoded))
			{
				unsafe_pbEncoded = (byte*)pinned_pbEncoded;
				fixed (int* pinned_pcbStructInfo = &(pcbStructInfo))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptDecodeObjectPointer(
										dwCertEncodingType, 
										lpszStructType, 
										unsafe_pbEncoded, 
										cbEncoded, 
										dwFlags, 
										((void*)pvStructInfo), 
										pinned_pcbStructInfo
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertVerifyTimeValidity, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] Internal_Cryptography_Pal_Native_FILETIME__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__FILETIME__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] Internal_Cryptography_Pal_Native_CERT_INFO__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_INFO__System_Security_Cryptography_X509Certificates *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertVerifyTimeValidity")]
		public static int CertVerifyTimeValidity(
					ref global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates pTimeToVerify, 
					global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates* pCertInfo)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates* pinned_pTimeToVerify = &(pTimeToVerify))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertVerifyTimeValidity(
									pinned_pTimeToVerify, 
									((global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates*)pCertInfo)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, CryptFindOIDInfo__1, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] __Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Cng__Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Security_Cryptography_OidGroup__System_Security_Cryptography_Encoding__OidGroup__System_Security_Cryptography_Encoding, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Crypt32", "CryptFindOIDInfo")]
		public static global::System.IntPtr CryptFindOIDInfo__1(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Cng dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptFindOIDInfo__1(
								dwKeyType, 
								pvKey, 
								group
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, CertVerifyCertificateChainPolicy__0, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeX509ChainHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Crypt32_CERT_CHAIN_POLICY_PARA__System_Net_Security____Interop_Crypt32_CERT_CHAIN_POLICY_PARA__System_Net_Security, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Crypt32_CERT_CHAIN_POLICY_STATUS__System_Net_Security____Interop_Crypt32_CERT_CHAIN_POLICY_STATUS__System_Net_Security, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Crypt32", "CertVerifyCertificateChainPolicy")]
		public static bool CertVerifyCertificateChainPolicy__0(
					global::System.IntPtr pszPolicyOID, 
					global::Microsoft.Win32.SafeHandles.SafeX509ChainHandle__System_Security_Cryptography_X509Certificates pChainContext, 
					ref global::_.Interop_Crypt32_CERT_CHAIN_POLICY_PARA__System_Net_Security pPolicyPara, 
					ref global::_.Interop_Crypt32_CERT_CHAIN_POLICY_STATUS__System_Net_Security pPolicyStatus)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			pChainContext.DangerousAddRef(ref addRefed);
			fixed (global::_.Interop_Crypt32_CERT_CHAIN_POLICY_PARA__System_Net_Security* pinned_pPolicyPara = &(pPolicyPara))
				fixed (global::_.Interop_Crypt32_CERT_CHAIN_POLICY_STATUS__System_Net_Security* pinned_pPolicyStatus = &(pPolicyStatus))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertVerifyCertificateChainPolicy__0(
										pszPolicyOID, 
										pChainContext.DangerousGetHandle(), 
										pinned_pPolicyPara, 
										pinned_pPolicyStatus
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				pChainContext.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertEnumCertificatesInStore__0, [fwd] [return] [EETypeRva:0x000419B0] __Interop_Crypt32_CERT_CONTEXT__System_Net_Security___ptr__Interop_Crypt32_CERT_CONTEXT__System_Net_Security *, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] __Interop_Crypt32_CERT_CONTEXT__System_Net_Security___ptr__Interop_Crypt32_CERT_CONTEXT__System_Net_Security *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Crypt32", "CertEnumCertificatesInStore")]
		public static global::_.Interop_Crypt32_CERT_CONTEXT__System_Net_Security* CertEnumCertificatesInStore__0(
					global::System.IntPtr hCertStore, 
					global::_.Interop_Crypt32_CERT_CONTEXT__System_Net_Security* pPrevCertContext)
		{
			// Setup
			global::_.Interop_Crypt32_CERT_CONTEXT__System_Net_Security* unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = (global::_.Interop_Crypt32_CERT_CONTEXT__System_Net_Security*)global::__Interop.crypt32_dll_PInvokes.CertEnumCertificatesInStore__0(
								hCertStore, 
								((global::_.Interop_Crypt32_CERT_CONTEXT__System_Net_Security*)pPrevCertContext)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return (global::_.Interop_Crypt32_CERT_CONTEXT__System_Net_Security*)unsafe___value;
		}

		// Signature, CertFreeCertificateContext__0, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Crypt32", "CertFreeCertificateContext")]
		public static bool CertFreeCertificateContext__0(global::System.IntPtr pCertContext)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertFreeCertificateContext__0(pCertContext);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'kernel32.dll'
	/// </summary>
	public unsafe static partial class kernel32_dll
	{
		// Signature, GetCPInfoExW, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] __Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages___ptr__Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Text.Encoding.CodePages, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetCPInfoExW")]
		public static int GetCPInfoExW(
					uint CodePage, 
					uint dwFlags, 
					global::_.Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages* lpCPInfoEx)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetCPInfoExW(
								CodePage, 
								dwFlags, 
								((global::_.Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages*)lpCPInfoEx)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+Kernel32", "FormatMessage")]
		public static int FormatMessage(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					char* lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_arguments = ((arguments != null 
						&& arguments.Length == 0) ? new global::System.IntPtr[1] : arguments))
			{
				unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.FormatMessage(
									dwFlags, 
									lpSource, 
									dwMessageId, 
									dwLanguageId, 
									((ushort*)lpBuffer), 
									nSize, 
									unsafe_arguments
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, LocalAlloc, [fwd] [return] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLocalAllocHandle__System_Net_Primitives____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_UIntPtr____w64 unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Primitives, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "LocalAlloc")]
		public static global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Net_Primitives LocalAlloc(
					int uFlags, 
					global::System.UIntPtr sizetdwBytes)
		{
			// Setup
			global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Net_Primitives __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Net_Primitives();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.LocalAlloc(
								uFlags, 
								sizetdwBytes
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, LocalFree, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Primitives, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "LocalFree")]
		public static global::System.IntPtr LocalFree(global::System.IntPtr handle)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.LocalFree(handle);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage__0, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "FormatMessage")]
		public static int FormatMessage__0(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					char* lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_arguments = ((arguments != null 
						&& arguments.Length == 0) ? new global::System.IntPtr[1] : arguments))
			{
				unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.FormatMessage__0(
									dwFlags, 
									lpSource, 
									dwMessageId, 
									dwLanguageId, 
									((ushort*)lpBuffer), 
									nSize, 
									unsafe_arguments
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage__1, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "FormatMessage")]
		public static int FormatMessage__1(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					char* lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_arguments = ((arguments != null 
						&& arguments.Length == 0) ? new global::System.IntPtr[1] : arguments))
			{
				unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.FormatMessage__1(
									dwFlags, 
									lpSource, 
									dwMessageId, 
									dwLanguageId, 
									((ushort*)lpBuffer), 
									nSize, 
									unsafe_arguments
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage__2, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("Microsoft.Win32.Primitives, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "FormatMessage")]
		public static int FormatMessage__2(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					char* lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_arguments = ((arguments != null 
						&& arguments.Length == 0) ? new global::System.IntPtr[1] : arguments))
			{
				unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.FormatMessage__2(
									dwFlags, 
									lpSource, 
									dwMessageId, 
									dwLanguageId, 
									((ushort*)lpBuffer), 
									nSize, 
									unsafe_arguments
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage__3, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "FormatMessage")]
		public static int FormatMessage__3(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					char* lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_arguments = ((arguments != null 
						&& arguments.Length == 0) ? new global::System.IntPtr[1] : arguments))
			{
				unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.FormatMessage__3(
									dwFlags, 
									lpSource, 
									dwMessageId, 
									dwLanguageId, 
									((ushort*)lpBuffer), 
									nSize, 
									unsafe_arguments
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, LocalAlloc__0, [fwd] [return] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLocalAllocHandle__System_Security_Principal_Windows____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_UIntPtr____w64 unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "LocalAlloc")]
		public static global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Security_Principal_Windows LocalAlloc__0(
					int uFlags, 
					global::System.UIntPtr sizetdwBytes)
		{
			// Setup
			global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Security_Principal_Windows __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Security_Principal_Windows();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.LocalAlloc__0(
								uFlags, 
								sizetdwBytes
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, GetCurrentThread, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetCurrentThread")]
		public static global::System.IntPtr GetCurrentThread()
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetCurrentThread();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, GetCurrentProcess, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetCurrentProcess")]
		public static global::System.IntPtr GetCurrentProcess()
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetCurrentProcess();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, CloseHandle, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "CloseHandle")]
		public static bool CloseHandle(global::System.IntPtr handle)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.CloseHandle(handle);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, LocalFree__0, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "LocalFree")]
		public static global::System.IntPtr LocalFree__0(global::System.IntPtr handle)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.LocalFree__0(handle);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, CheckTokenMembershipEx, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeAccessTokenHandle__System_Security_Principal_Windows____w64 int, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00040848] bool__System.Boolean, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "CheckTokenMembershipEx")]
		public static bool CheckTokenMembershipEx(
					global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows TokenHandle, 
					byte[] SidToCheck, 
					uint Flags, 
					ref bool IsMember)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_SidToCheck;
			int unsafe_IsMember;
			int unsafe___value;
			// Marshalling
			TokenHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_SidToCheck = ((SidToCheck != null 
						&& SidToCheck.Length == 0) ? new byte[1] : SidToCheck))
			{
				unsafe_SidToCheck = (byte*)pinned_SidToCheck;
				unsafe_IsMember = (IsMember ? 1 : 0);
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.CheckTokenMembershipEx(
									TokenHandle.DangerousGetHandle(), 
									unsafe_SidToCheck, 
									Flags, 
									&(unsafe_IsMember)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				IsMember = unsafe_IsMember != 0;
			}
			if (addRefed)
				TokenHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, DuplicateHandle, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeAccessTokenHandle__System_Security_Principal_Windows____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "DuplicateHandle")]
		public static bool DuplicateHandle(
					global::System.IntPtr hSourceProcessHandle, 
					global::System.IntPtr hSourceHandle, 
					global::System.IntPtr hTargetProcessHandle, 
					ref global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows lpTargetHandle, 
					uint dwDesiredAccess, 
					bool bInheritHandle, 
					uint dwOptions)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_lpTargetHandle;
			global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows out_lpTargetHandle;
			global::System.IntPtr prev_unsafe_lpTargetHandle;
			int unsafe___value;
			// Marshalling
			lpTargetHandle.DangerousAddRef(ref addRefed);
			unsafe_lpTargetHandle = lpTargetHandle.DangerousGetHandle();
			prev_unsafe_lpTargetHandle = unsafe_lpTargetHandle;
			out_lpTargetHandle = new global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.DuplicateHandle(
								hSourceProcessHandle, 
								hSourceHandle, 
								hTargetProcessHandle, 
								&(unsafe_lpTargetHandle), 
								dwDesiredAccess, 
								(bInheritHandle ? 1 : 0), 
								dwOptions
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				lpTargetHandle.DangerousRelease();
			if (prev_unsafe_lpTargetHandle != unsafe_lpTargetHandle)
			{
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									out_lpTargetHandle, 
									unsafe_lpTargetHandle
								);
				lpTargetHandle = out_lpTargetHandle;
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, SetFileCompletionNotificationModes, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [EETypeRva:0x00042D60] __Interop_Kernel32_FileCompletionNotificationModes__System_Net_Sockets__Interop_Kernel32_FileCompletionNotificationModes__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "SetFileCompletionNotificationModes")]
		public static bool SetFileCompletionNotificationModes(
					global::System.Runtime.InteropServices.SafeHandle handle, 
					global::_.Interop_Kernel32_FileCompletionNotificationModes__System_Net_Sockets flags)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			handle.DangerousAddRef(ref addRefed);
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.SetFileCompletionNotificationModes(
								handle.DangerousGetHandle(), 
								flags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				handle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-com-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_com_l1_1_0_dll
	{
		// Signature, CoCreateInstance, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.StackTraceGenerator, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.StackTraceGenerator.StackTraceGenerator", "CoCreateInstance")]
		public static int CoCreateInstance(
					byte* rclsid, 
					global::System.IntPtr pUnkOuter, 
					int dwClsContext, 
					byte* riid, 
					out global::System.IntPtr ppv)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_ppv = &(ppv))
			{
				// Call to native method
				unsafe___value = global::__Interop.api_ms_win_core_com_l1_1_0_dll_PInvokes.CoCreateInstance(
									((byte*)rclsid), 
									pUnkOuter, 
									dwClsContext, 
									((byte*)riid), 
									pinned_ppv
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'advapi32.dll'
	/// </summary>
	public unsafe static partial class advapi32_dll
	{
		// Signature, CryptAcquireContext, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] Internal_Cryptography_Pal_Native_CryptAcquireContextFlags__System_Security_Cryptography_X509Certificates__CryptAcquireContextFlags__System_Security_Cryptography_X509Certificates, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+cryptoapi", "CryptAcquireContext")]
		public static bool CryptAcquireContext(
					out global::System.IntPtr psafeProvHandle, 
					char* pszContainer, 
					char* pszProvider, 
					int dwProvType, 
					global::Internal_Cryptography_Pal_Native.CryptAcquireContextFlags__System_Security_Cryptography_X509Certificates dwFlags)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_psafeProvHandle = &(psafeProvHandle))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptAcquireContext(
									pinned_psafeProvHandle, 
									((ushort*)pszContainer), 
									((ushort*)pszProvider), 
									dwProvType, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptGetKeyParam, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] System_Security_Cryptography_SafeKeyHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptGetKeyParam")]
		public static bool CryptGetKeyParam(
					global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp safeKeyHandle, 
					int dwParam, 
					byte[] pbData, 
					ref int pdwDataLen, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pbData;
			int unsafe___value;
			// Marshalling
			safeKeyHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pbData = ((pbData != null 
						&& pbData.Length == 0) ? new byte[1] : pbData))
			{
				unsafe_pbData = (byte*)pinned_pbData;
				fixed (int* pinned_pdwDataLen = &(pdwDataLen))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptGetKeyParam(
										safeKeyHandle.DangerousGetHandle(), 
										dwParam, 
										unsafe_pbData, 
										pinned_pdwDataLen, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			if (addRefed)
				safeKeyHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptGetDefaultProvider, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [EETypeRva:0x00041CF4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptGetDefaultProvider")]
		public static bool CryptGetDefaultProvider(
					int dwProvType, 
					global::System.IntPtr pdwReserved, 
					int dwFlags, 
					global::System.Text.StringBuilder pszProvName, 
					ref int IntPtrProvName)
		{
			// Setup
			ushort* unsafe_pszProvName = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				if (pszProvName == null)
					unsafe_pszProvName = null;
				else
				{
					unsafe_pszProvName = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(pszProvName.Capacity * 2 
										+ 2)));
					if (unsafe_pszProvName == null)
						throw new global::System.OutOfMemoryException();
				}
				if (unsafe_pszProvName != null)
					global::System.Runtime.InteropServices.McgMarshal.StringBuilderToUnicodeString(
										pszProvName, 
										unsafe_pszProvName
									);
				fixed (int* pinned_IntPtrProvName = &(IntPtrProvName))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptGetDefaultProvider(
										dwProvType, 
										pdwReserved, 
										dwFlags, 
										unsafe_pszProvName, 
										pinned_IntPtrProvName
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
				if (pszProvName != null)
					global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
										unsafe_pszProvName, 
										pszProvName
									);
				// Return
				return unsafe___value != 0;
			}
			finally
			{
				// Cleanup
				if (unsafe_pszProvName != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pszProvName);
			}
		}

		// Signature, CryptAcquireContext__0, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] System_Security_Cryptography_SafeProvHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptAcquireContext")]
		public static bool CryptAcquireContext__0(
					out global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp psafeProvHandle, 
					string pszContainer, 
					string pszProvider, 
					int dwProvType, 
					uint dwFlags)
		{
			// Setup
			global::System.IntPtr unsafe_psafeProvHandle;
			ushort* unsafe_pszContainer = default(ushort*);
			ushort* unsafe_pszProvider = default(ushort*);
			int unsafe___value;
			// Marshalling
			psafeProvHandle = new global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp();
			unsafe_psafeProvHandle = psafeProvHandle.DangerousGetHandle();
			fixed (char* pinned_pszContainer = pszContainer)
			{
				unsafe_pszContainer = (ushort*)pinned_pszContainer;
				fixed (char* pinned_pszProvider = pszProvider)
				{
					unsafe_pszProvider = (ushort*)pinned_pszProvider;
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptAcquireContext__0(
										&(unsafe_psafeProvHandle), 
										unsafe_pszContainer, 
										unsafe_pszProvider, 
										dwProvType, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								psafeProvHandle, 
								unsafe_psafeProvHandle
							);
			// Return
			return unsafe___value != 0;
		}

		// Signature, _CryptGetUserKey, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] System_Security_Cryptography_SafeProvHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] System_Security_Cryptography_SafeKeyHandle__System_Security_Cryptography_Csp____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "_CryptGetUserKey")]
		public static bool _CryptGetUserKey(
					global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp safeProvHandle, 
					int dwKeySpec, 
					out global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp safeKeyHandle)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_safeKeyHandle;
			int unsafe___value;
			// Marshalling
			safeProvHandle.DangerousAddRef(ref addRefed);
			safeKeyHandle = new global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp();
			unsafe_safeKeyHandle = safeKeyHandle.DangerousGetHandle();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes._CryptGetUserKey(
								safeProvHandle.DangerousGetHandle(), 
								dwKeySpec, 
								&(unsafe_safeKeyHandle)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								safeKeyHandle, 
								unsafe_safeKeyHandle
							);
			if (addRefed)
				safeProvHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptGetProvParam, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [EETypeRva:0x00042D60] __Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp__Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "CryptGetProvParam")]
		public static bool CryptGetProvParam(
					global::System.Runtime.InteropServices.SafeHandle safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					global::System.IntPtr pbData, 
					ref int dwDataLen, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			safeProvHandle.DangerousAddRef(ref addRefed);
			fixed (int* pinned_dwDataLen = &(dwDataLen))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptGetProvParam(
									safeProvHandle.DangerousGetHandle(), 
									dwParam, 
									pbData, 
									pinned_dwDataLen, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				safeProvHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptDestroyKey, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptDestroyKey")]
		public static bool CryptDestroyKey(global::System.IntPtr hKey)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptDestroyKey(hKey);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptReleaseContext, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptReleaseContext")]
		public static bool CryptReleaseContext(
					global::System.IntPtr safeProvHandle, 
					int dwFlags)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptReleaseContext(
								safeProvHandle, 
								dwFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, _CryptImportKey, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] System_Security_Cryptography_SafeProvHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000434A4] System_Security_Cryptography_SafeKeyHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] System_Security_Cryptography_SafeKeyHandle__System_Security_Cryptography_Csp____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "_CryptImportKey")]
		public static bool _CryptImportKey(
					global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp hProv, 
					byte[] pbData, 
					int dwDataLen, 
					global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp hPubKey, 
					int dwFlags, 
					out global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp phKey)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pbData;
			bool addRefed_1 = false;
			global::System.IntPtr unsafe_phKey;
			int unsafe___value;
			// Marshalling
			hProv.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pbData = ((pbData != null 
						&& pbData.Length == 0) ? new byte[1] : pbData))
			{
				unsafe_pbData = (byte*)pinned_pbData;
				hPubKey.DangerousAddRef(ref addRefed_1);
				phKey = new global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp();
				unsafe_phKey = phKey.DangerousGetHandle();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes._CryptImportKey(
									hProv.DangerousGetHandle(), 
									unsafe_pbData, 
									dwDataLen, 
									hPubKey.DangerousGetHandle(), 
									dwFlags, 
									&(unsafe_phKey)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									phKey, 
									unsafe_phKey
								);
				if (addRefed_1)
					hPubKey.DangerousRelease();
			}
			if (addRefed)
				hProv.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptSetProvParamIndirectPtr, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] System_Security_Cryptography_SafeProvHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x00042D60] __Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp__Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptSetProvParamIndirectPtr")]
		public static bool CryptSetProvParamIndirectPtr(
					global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					ref global::System.IntPtr pbData, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			safeProvHandle.DangerousAddRef(ref addRefed);
			fixed (global::System.IntPtr* pinned_pbData = &(pbData))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptSetProvParamIndirectPtr(
									safeProvHandle.DangerousGetHandle(), 
									dwParam, 
									pinned_pbData, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				safeProvHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptSetProvParam, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [EETypeRva:0x00042D60] __Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp__Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "CryptSetProvParam")]
		public static bool CryptSetProvParam(
					global::System.Runtime.InteropServices.SafeHandle safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					global::System.IntPtr pbData, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			safeProvHandle.DangerousAddRef(ref addRefed);
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptSetProvParam(
								safeProvHandle.DangerousGetHandle(), 
								dwParam, 
								pbData, 
								dwFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				safeProvHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, _CryptGenKey, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] System_Security_Cryptography_SafeProvHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] System_Security_Cryptography_SafeKeyHandle__System_Security_Cryptography_Csp____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "_CryptGenKey")]
		public static bool _CryptGenKey(
					global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp safeProvHandle, 
					int Algid, 
					int dwFlags, 
					out global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp safeKeyHandle)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_safeKeyHandle;
			int unsafe___value;
			// Marshalling
			safeProvHandle.DangerousAddRef(ref addRefed);
			safeKeyHandle = new global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp();
			unsafe_safeKeyHandle = safeKeyHandle.DangerousGetHandle();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes._CryptGenKey(
								safeProvHandle.DangerousGetHandle(), 
								Algid, 
								dwFlags, 
								&(unsafe_safeKeyHandle)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								safeKeyHandle, 
								unsafe_safeKeyHandle
							);
			if (addRefed)
				safeProvHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, RevertToSelf, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "RevertToSelf")]
		public static bool RevertToSelf()
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.RevertToSelf();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, ImpersonateLoggedOnUser, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeAccessTokenHandle__System_Security_Principal_Windows____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "ImpersonateLoggedOnUser")]
		public static bool ImpersonateLoggedOnUser(global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows userToken)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			userToken.DangerousAddRef(ref addRefed);
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.ImpersonateLoggedOnUser(userToken.DangerousGetHandle());
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				userToken.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, GetTokenInformation, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeAccessTokenHandle__System_Security_Principal_Windows____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLocalAllocHandle__System_Security_Principal_Windows____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "GetTokenInformation")]
		public static bool GetTokenInformation(
					global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows TokenHandle, 
					uint TokenInformationClass, 
					global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Security_Principal_Windows TokenInformation, 
					uint TokenInformationLength, 
					out uint ReturnLength)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			int unsafe___value;
			// Marshalling
			TokenHandle.DangerousAddRef(ref addRefed);
			TokenInformation.DangerousAddRef(ref addRefed_1);
			fixed (uint* pinned_ReturnLength = &(ReturnLength))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes.GetTokenInformation(
									TokenHandle.DangerousGetHandle(), 
									TokenInformationClass, 
									TokenInformation.DangerousGetHandle(), 
									TokenInformationLength, 
									pinned_ReturnLength
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed_1)
				TokenInformation.DangerousRelease();
			if (addRefed)
				TokenHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, OpenThreadToken, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Security_Principal_TokenAccessLevels__System_Security_Principal_Windows__TokenAccessLevels__System_Security_Principal_Windows, [fwd] [in] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeAccessTokenHandle__System_Security_Principal_Windows____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "OpenThreadToken")]
		public static bool OpenThreadToken(
					global::System.IntPtr ThreadHandle, 
					global::System_Security_Principal.TokenAccessLevels__System_Security_Principal_Windows dwDesiredAccess, 
					bool bOpenAsSelf, 
					out global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows phThreadToken)
		{
			// Setup
			global::System.IntPtr unsafe_phThreadToken;
			int unsafe___value;
			// Marshalling
			phThreadToken = new global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows();
			unsafe_phThreadToken = phThreadToken.DangerousGetHandle();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.OpenThreadToken(
								ThreadHandle, 
								dwDesiredAccess, 
								(bOpenAsSelf ? 1 : 0), 
								&(unsafe_phThreadToken)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phThreadToken, 
								unsafe_phThreadToken
							);
			// Return
			return unsafe___value != 0;
		}

		// Signature, OpenProcessToken, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Security_Principal_TokenAccessLevels__System_Security_Principal_Windows__TokenAccessLevels__System_Security_Principal_Windows, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeAccessTokenHandle__System_Security_Principal_Windows____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "OpenProcessToken")]
		public static bool OpenProcessToken(
					global::System.IntPtr ProcessToken, 
					global::System_Security_Principal.TokenAccessLevels__System_Security_Principal_Windows DesiredAccess, 
					out global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows TokenHandle)
		{
			// Setup
			global::System.IntPtr unsafe_TokenHandle;
			int unsafe___value;
			// Marshalling
			TokenHandle = new global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows();
			unsafe_TokenHandle = TokenHandle.DangerousGetHandle();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.OpenProcessToken(
								ProcessToken, 
								DesiredAccess, 
								&(unsafe_TokenHandle)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								TokenHandle, 
								unsafe_TokenHandle
							);
			// Return
			return unsafe___value != 0;
		}

		// Signature, LsaNtStatusToWinError, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "LsaNtStatusToWinError")]
		public static uint LsaNtStatusToWinError(uint status)
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.LsaNtStatusToWinError(status);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, DuplicateTokenEx, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeAccessTokenHandle__System_Security_Principal_Windows____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeAccessTokenHandle__System_Security_Principal_Windows____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "DuplicateTokenEx")]
		public static bool DuplicateTokenEx(
					global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows hExistingToken, 
					uint dwDesiredAccess, 
					global::System.IntPtr lpTokenAttributes, 
					uint ImpersonationLevel, 
					uint TokenType, 
					ref global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows phNewToken)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			global::System.IntPtr unsafe_phNewToken;
			global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows out_phNewToken;
			global::System.IntPtr prev_unsafe_phNewToken;
			int unsafe___value;
			// Marshalling
			hExistingToken.DangerousAddRef(ref addRefed);
			phNewToken.DangerousAddRef(ref addRefed_1);
			unsafe_phNewToken = phNewToken.DangerousGetHandle();
			prev_unsafe_phNewToken = unsafe_phNewToken;
			out_phNewToken = new global::Microsoft.Win32.SafeHandles.SafeAccessTokenHandle__System_Security_Principal_Windows();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.DuplicateTokenEx(
								hExistingToken.DangerousGetHandle(), 
								dwDesiredAccess, 
								lpTokenAttributes, 
								ImpersonationLevel, 
								TokenType, 
								&(unsafe_phNewToken)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed_1)
				phNewToken.DangerousRelease();
			if (prev_unsafe_phNewToken != unsafe_phNewToken)
			{
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									out_phNewToken, 
									unsafe_phNewToken
								);
				phNewToken = out_phNewToken;
			}
			if (addRefed)
				hExistingToken.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, GetTokenInformation__0, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "GetTokenInformation")]
		public static bool GetTokenInformation__0(
					global::System.IntPtr TokenHandle, 
					uint TokenInformationClass, 
					global::System.IntPtr TokenInformation, 
					uint TokenInformationLength, 
					out uint ReturnLength)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (uint* pinned_ReturnLength = &(ReturnLength))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes.GetTokenInformation__0(
									TokenHandle, 
									TokenInformationClass, 
									TokenInformation, 
									TokenInformationLength, 
									pinned_ReturnLength
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, LsaLookupSids, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLsaPolicyHandle__System_Security_Principal_Windows____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLsaMemoryHandle__System_Security_Principal_Windows____w64 int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLsaMemoryHandle__System_Security_Principal_Windows____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "LsaLookupSids")]
		public static uint LsaLookupSids(
					global::Microsoft.Win32.SafeHandles.SafeLsaPolicyHandle__System_Security_Principal_Windows handle, 
					int count, 
					global::System.IntPtr[] sids, 
					ref global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows referencedDomains, 
					ref global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows names)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr* unsafe_sids;
			bool addRefed_1 = false;
			global::System.IntPtr unsafe_referencedDomains;
			global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows out_referencedDomains;
			global::System.IntPtr prev_unsafe_referencedDomains;
			bool addRefed_2 = false;
			global::System.IntPtr unsafe_names;
			global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows out_names;
			global::System.IntPtr prev_unsafe_names;
			uint unsafe___value;
			// Marshalling
			handle.DangerousAddRef(ref addRefed);
			fixed (global::System.IntPtr* pinned_sids = ((sids != null 
						&& sids.Length == 0) ? new global::System.IntPtr[1] : sids))
			{
				unsafe_sids = (global::System.IntPtr*)pinned_sids;
				referencedDomains.DangerousAddRef(ref addRefed_1);
				unsafe_referencedDomains = referencedDomains.DangerousGetHandle();
				prev_unsafe_referencedDomains = unsafe_referencedDomains;
				out_referencedDomains = new global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows();
				names.DangerousAddRef(ref addRefed_2);
				unsafe_names = names.DangerousGetHandle();
				prev_unsafe_names = unsafe_names;
				out_names = new global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes.LsaLookupSids(
									handle.DangerousGetHandle(), 
									count, 
									unsafe_sids, 
									&(unsafe_referencedDomains), 
									&(unsafe_names)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (addRefed_2)
					names.DangerousRelease();
				if (prev_unsafe_names != unsafe_names)
				{
					global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
										out_names, 
										unsafe_names
									);
					names = out_names;
				}
				if (addRefed_1)
					referencedDomains.DangerousRelease();
				if (prev_unsafe_referencedDomains != unsafe_referencedDomains)
				{
					global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
										out_referencedDomains, 
										unsafe_referencedDomains
									);
					referencedDomains = out_referencedDomains;
				}
			}
			if (addRefed)
				handle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, LsaLookupNames2, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLsaPolicyHandle__System_Security_Principal_Windows____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000424E8] rg___Interop_UNICODE_STRING__System_Security_Principal_Windows____Interop_UNICODE_STRING__System_Security_Principal_Windows *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLsaMemoryHandle__System_Security_Principal_Windows____w64 int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLsaMemoryHandle__System_Security_Principal_Windows____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "LsaLookupNames2")]
		public static uint LsaLookupNames2(
					global::Microsoft.Win32.SafeHandles.SafeLsaPolicyHandle__System_Security_Principal_Windows handle, 
					int flags, 
					int count, 
					global::_.Interop_UNICODE_STRING__System_Security_Principal_Windows[] names, 
					ref global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows referencedDomains, 
					ref global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows sids)
		{
			// Setup
			bool addRefed = false;
			global::_.Interop_UNICODE_STRING__System_Security_Principal_Windows__Impl.UnsafeType* unsafe_names = default(global::_.Interop_UNICODE_STRING__System_Security_Principal_Windows__Impl.UnsafeType*);
			bool addRefed_1 = false;
			global::System.IntPtr unsafe_referencedDomains;
			global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows out_referencedDomains;
			global::System.IntPtr prev_unsafe_referencedDomains;
			bool addRefed_2 = false;
			global::System.IntPtr unsafe_sids;
			global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows out_sids;
			global::System.IntPtr prev_unsafe_sids;
			uint unsafe___value;
			try
			{
				// Marshalling
				handle.DangerousAddRef(ref addRefed);
				if (names == null)
					unsafe_names = null;
				else
				{
					if (names != null)
						unsafe_names = (global::_.Interop_UNICODE_STRING__System_Security_Principal_Windows__Impl.UnsafeType*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(((global::System.IntPtr)checked(names.Length * sizeof(global::_.Interop_UNICODE_STRING__System_Security_Principal_Windows__Impl.UnsafeType))));
					if (names != null)
						for (uint mcgIdx = 0; (mcgIdx < names.Length); mcgIdx++)
						{
							// [fwd] [in] [optional] [EETypeRva:0x000421C0] __Interop_UNICODE_STRING__System_Security_Principal_Windows____Interop_UNICODE_STRING__System_Security_Principal_Windows names
							global::_.Interop_UNICODE_STRING__System_Security_Principal_Windows__Impl.Marshal__SafeToUnsafe(
												ref names[mcgIdx], 
												out unsafe_names[mcgIdx]
											);
						}
				}
				referencedDomains.DangerousAddRef(ref addRefed_1);
				unsafe_referencedDomains = referencedDomains.DangerousGetHandle();
				prev_unsafe_referencedDomains = unsafe_referencedDomains;
				out_referencedDomains = new global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows();
				sids.DangerousAddRef(ref addRefed_2);
				unsafe_sids = sids.DangerousGetHandle();
				prev_unsafe_sids = unsafe_sids;
				out_sids = new global::Microsoft.Win32.SafeHandles.SafeLsaMemoryHandle__System_Security_Principal_Windows();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes.LsaLookupNames2(
									handle.DangerousGetHandle(), 
									flags, 
									count, 
									unsafe_names, 
									&(unsafe_referencedDomains), 
									&(unsafe_sids)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (addRefed_2)
					sids.DangerousRelease();
				if (prev_unsafe_sids != unsafe_sids)
				{
					global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
										out_sids, 
										unsafe_sids
									);
					sids = out_sids;
				}
				if (addRefed_1)
					referencedDomains.DangerousRelease();
				if (prev_unsafe_referencedDomains != unsafe_referencedDomains)
				{
					global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
										out_referencedDomains, 
										unsafe_referencedDomains
									);
					referencedDomains = out_referencedDomains;
				}
				if (addRefed)
					handle.DangerousRelease();
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_names != null)
					for (uint mcgIdx_1 = 0; (mcgIdx_1 < names.Length); mcgIdx_1++)
					{
						// [fwd] [in] [out] [optional] [EETypeRva:0x000421C0] __Interop_UNICODE_STRING__System_Security_Principal_Windows____Interop_UNICODE_STRING__System_Security_Principal_Windows names
						global::_.Interop_UNICODE_STRING__System_Security_Principal_Windows__Impl.Cleanup__Unsafe(ref unsafe_names[mcgIdx_1]);
					}
				global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_names);
			}
		}

		// Signature, LsaOpenPolicy, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_LSA_OBJECT_ATTRIBUTES__System_Security_Principal_Windows____Interop_LSA_OBJECT_ATTRIBUTES__System_Security_Principal_Windows, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLsaPolicyHandle__System_Security_Principal_Windows____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "LsaOpenPolicy")]
		public static uint LsaOpenPolicy(
					string systemName, 
					ref global::_.Interop_LSA_OBJECT_ATTRIBUTES__System_Security_Principal_Windows attributes, 
					int accessMask, 
					out global::Microsoft.Win32.SafeHandles.SafeLsaPolicyHandle__System_Security_Principal_Windows handle)
		{
			// Setup
			ushort* unsafe_systemName = default(ushort*);
			global::System.IntPtr unsafe_handle;
			uint unsafe___value;
			// Marshalling
			fixed (char* pinned_systemName = systemName)
			{
				unsafe_systemName = (ushort*)pinned_systemName;
				fixed (global::_.Interop_LSA_OBJECT_ATTRIBUTES__System_Security_Principal_Windows* pinned_attributes = &(attributes))
				{
					handle = new global::Microsoft.Win32.SafeHandles.SafeLsaPolicyHandle__System_Security_Principal_Windows();
					unsafe_handle = handle.DangerousGetHandle();
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.advapi32_dll_PInvokes.LsaOpenPolicy(
										unsafe_systemName, 
										pinned_attributes, 
										accessMask, 
										&(unsafe_handle)
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
										handle, 
										unsafe_handle
									);
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, LsaClose, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "LsaClose")]
		public static int LsaClose(global::System.IntPtr handle)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.LsaClose(handle);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, LsaFreeMemory, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "LsaFreeMemory")]
		public static int LsaFreeMemory(global::System.IntPtr handle)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.LsaFreeMemory(handle);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'ws2_32.dll'
	/// </summary>
	public unsafe static partial class ws2_32_dll
	{
		// Signature, WSAGetOverlappedResult, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_Threading_NativeOverlapped__System_Private_CoreLib___ptrSystem_Threading__NativeOverlapped__System_Private_CoreLib *, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D60] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSAGetOverlappedResult")]
		public static bool WSAGetOverlappedResult(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System_Threading.NativeOverlapped__System_Private_CoreLib* overlapped, 
					out uint bytesTransferred, 
					bool wait, 
					out global::System_Net_Sockets.SocketFlags__System_Net_Sockets socketFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (uint* pinned_bytesTransferred = &(bytesTransferred))
				fixed (global::System_Net_Sockets.SocketFlags__System_Net_Sockets* pinned_socketFlags = &(socketFlags))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.ws2_32_dll_PInvokes.WSAGetOverlappedResult(
										socketHandle.DangerousGetHandle(), 
										((global::System_Threading.NativeOverlapped__System_Private_CoreLib*)overlapped), 
										pinned_bytesTransferred, 
										(wait ? 1 : 0), 
										pinned_socketFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, setsockopt, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					ref global::System.IntPtr pointer, 
					int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (global::System.IntPtr* pinned_pointer = &(pointer))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.setsockopt(
									socketHandle.DangerousGetHandle(), 
									optionLevel, 
									optionName, 
									pinned_pointer, 
									optionLength
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, setsockopt__0, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt__0(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					byte[] optionValue, 
					int optionLength)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_optionValue;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_optionValue = ((optionValue != null 
						&& optionValue.Length == 0) ? new byte[1] : optionValue))
			{
				unsafe_optionValue = (byte*)pinned_optionValue;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.setsockopt__0(
									socketHandle.DangerousGetHandle(), 
									optionLevel, 
									optionName, 
									unsafe_optionValue, 
									optionLength
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, getsockname, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [out] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getsockname")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives getsockname(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					byte[] socketAddress, 
					ref int socketAddressSize)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_socketAddress;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_socketAddress = ((socketAddress != null 
						&& socketAddress.Length == 0) ? new byte[1] : socketAddress))
			{
				unsafe_socketAddress = (byte*)pinned_socketAddress;
				fixed (int* pinned_socketAddressSize = &(socketAddressSize))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.ws2_32_dll_PInvokes.getsockname(
										socketHandle.DangerousGetHandle(), 
										unsafe_socketAddress, 
										pinned_socketAddressSize
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, getpeername, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [out] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getpeername")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives getpeername(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					byte[] socketAddress, 
					ref int socketAddressSize)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_socketAddress;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_socketAddress = ((socketAddress != null 
						&& socketAddress.Length == 0) ? new byte[1] : socketAddress))
			{
				unsafe_socketAddress = (byte*)pinned_socketAddress;
				fixed (int* pinned_socketAddressSize = &(socketAddressSize))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.ws2_32_dll_PInvokes.getpeername(
										socketHandle.DangerousGetHandle(), 
										unsafe_socketAddress, 
										pinned_socketAddressSize
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, WSAStartup, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000419B0] short__short, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000421C0] __Interop_Winsock_WSAData__System_Net_NameResolution____Interop_Winsock_WSAData__System_Net_NameResolution, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSAStartup")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives WSAStartup(
					short wVersionRequested, 
					out global::_.Interop_Winsock_WSAData__System_Net_NameResolution lpWSAData)
		{
			// Setup
			global::_.Interop_Winsock_WSAData__System_Net_NameResolution__Impl.UnsafeType unsafe_lpWSAData = default(global::_.Interop_Winsock_WSAData__System_Net_NameResolution__Impl.UnsafeType);
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			unsafe_lpWSAData = default(global::_.Interop_Winsock_WSAData__System_Net_NameResolution__Impl.UnsafeType);
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.ws2_32_dll_PInvokes.WSAStartup(
								wVersionRequested, 
								&(unsafe_lpWSAData)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::_.Interop_Winsock_WSAData__System_Net_NameResolution__Impl.Marshal__UnsafeToSafe(
								ref unsafe_lpWSAData, 
								out lpWSAData
							);
			// Return
			return unsafe___value;
		}

		// Signature, select, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, [fwd] [in] [out] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, [fwd] [in] [out] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Winsock_TimeValue__System_Net_Sockets____Interop_Winsock_TimeValue__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "select")]
		public static int select(
					int ignoredParameter, 
					global::System.IntPtr[] readfds, 
					global::System.IntPtr[] writefds, 
					global::System.IntPtr[] exceptfds, 
					ref global::_.Interop_Winsock_TimeValue__System_Net_Sockets timeout)
		{
			// Setup
			global::System.IntPtr* unsafe_readfds;
			global::System.IntPtr* unsafe_writefds;
			global::System.IntPtr* unsafe_exceptfds;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_readfds = ((readfds != null 
						&& readfds.Length == 0) ? new global::System.IntPtr[1] : readfds))
			{
				unsafe_readfds = (global::System.IntPtr*)pinned_readfds;
				fixed (global::System.IntPtr* pinned_writefds = ((writefds != null 
							&& writefds.Length == 0) ? new global::System.IntPtr[1] : writefds))
				{
					unsafe_writefds = (global::System.IntPtr*)pinned_writefds;
					fixed (global::System.IntPtr* pinned_exceptfds = ((exceptfds != null 
								&& exceptfds.Length == 0) ? new global::System.IntPtr[1] : exceptfds))
					{
						unsafe_exceptfds = (global::System.IntPtr*)pinned_exceptfds;
						fixed (global::_.Interop_Winsock_TimeValue__System_Net_Sockets* pinned_timeout = &(timeout))
						{
							global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
							// Call to native method
							unsafe___value = global::__Interop.ws2_32_dll_PInvokes.select(
												ignoredParameter, 
												unsafe_readfds, 
												unsafe_writefds, 
												unsafe_exceptfds, 
												pinned_timeout
											);
							global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
							global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
						}
					}
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, select__0, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, [fwd] [in] [out] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, [fwd] [in] [out] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "select")]
		public static int select__0(
					int ignoredParameter, 
					global::System.IntPtr[] readfds, 
					global::System.IntPtr[] writefds, 
					global::System.IntPtr[] exceptfds, 
					global::System.IntPtr nullTimeout)
		{
			// Setup
			global::System.IntPtr* unsafe_readfds;
			global::System.IntPtr* unsafe_writefds;
			global::System.IntPtr* unsafe_exceptfds;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_readfds = ((readfds != null 
						&& readfds.Length == 0) ? new global::System.IntPtr[1] : readfds))
			{
				unsafe_readfds = (global::System.IntPtr*)pinned_readfds;
				fixed (global::System.IntPtr* pinned_writefds = ((writefds != null 
							&& writefds.Length == 0) ? new global::System.IntPtr[1] : writefds))
				{
					unsafe_writefds = (global::System.IntPtr*)pinned_writefds;
					fixed (global::System.IntPtr* pinned_exceptfds = ((exceptfds != null 
								&& exceptfds.Length == 0) ? new global::System.IntPtr[1] : exceptfds))
					{
						unsafe_exceptfds = (global::System.IntPtr*)pinned_exceptfds;
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.ws2_32_dll_PInvokes.select__0(
											ignoredParameter, 
											unsafe_readfds, 
											unsafe_writefds, 
											unsafe_exceptfds, 
											nullTimeout
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, ioctlsocket, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "ioctlsocket")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives ioctlsocket(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					int cmd, 
					ref int argp)
		{
			// Setup
			bool addRefed = false;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (int* pinned_argp = &(argp))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.ioctlsocket(
									socketHandle.DangerousGetHandle(), 
									cmd, 
									pinned_argp
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, shutdown, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "shutdown")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives shutdown(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					int how)
		{
			// Setup
			bool addRefed = false;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.ws2_32_dll_PInvokes.shutdown(
								socketHandle.DangerousGetHandle(), 
								how
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, setsockopt__1, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt__1(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					ref int optionValue, 
					int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (int* pinned_optionValue = &(optionValue))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.setsockopt__1(
									socketHandle.DangerousGetHandle(), 
									optionLevel, 
									optionName, 
									pinned_optionValue, 
									optionLength
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, recv, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "recv")]
		public static int recv(
					global::System.IntPtr socketHandle, 
					byte* pinnedBuffer, 
					int len, 
					global::System_Net_Sockets.SocketFlags__System_Net_Sockets socketFlags)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.ws2_32_dll_PInvokes.recv(
								socketHandle, 
								((byte*)pinnedBuffer), 
								len, 
								socketFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, WSAIoctl, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_Guid__System.Guid, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSAIoctl")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives WSAIoctl(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					int ioControlCode, 
					ref global::System.Guid guid, 
					int guidSize, 
					out global::System.IntPtr funcPtr, 
					int funcPtrSize, 
					out int bytesTransferred, 
					global::System.IntPtr shouldBeNull, 
					global::System.IntPtr shouldBeNull2)
		{
			// Setup
			bool addRefed = false;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (global::System.Guid* pinned_guid = &(guid))
				fixed (global::System.IntPtr* pinned_funcPtr = &(funcPtr))
					fixed (int* pinned_bytesTransferred = &(bytesTransferred))
					{
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.ws2_32_dll_PInvokes.WSAIoctl(
											socketHandle.DangerousGetHandle(), 
											ioControlCode, 
											pinned_guid, 
											guidSize, 
											pinned_funcPtr, 
											funcPtrSize, 
											pinned_bytesTransferred, 
											shouldBeNull, 
											shouldBeNull2
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, GetAddrInfoW, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] System_Net_Sockets_AddressInfo__System_Net_NameResolution__System_Net_Sockets__AddressInfo__System_Net_NameResolution, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] System_Net_Sockets_SafeFreeAddrInfo__System_Net_NameResolution____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "GetAddrInfoW")]
		public static int GetAddrInfoW(
					string nodename, 
					string servicename, 
					ref global::System_Net_Sockets.AddressInfo__System_Net_NameResolution hints, 
					out global::System.Net.Sockets.SafeFreeAddrInfo__System_Net_NameResolution handle)
		{
			// Setup
			ushort* unsafe_nodename = default(ushort*);
			ushort* unsafe_servicename = default(ushort*);
			global::System.IntPtr unsafe_handle;
			int unsafe___value;
			// Marshalling
			fixed (char* pinned_nodename = nodename)
			{
				unsafe_nodename = (ushort*)pinned_nodename;
				fixed (char* pinned_servicename = servicename)
				{
					unsafe_servicename = (ushort*)pinned_servicename;
					fixed (global::System_Net_Sockets.AddressInfo__System_Net_NameResolution* pinned_hints = &(hints))
					{
						handle = new global::System.Net.Sockets.SafeFreeAddrInfo__System_Net_NameResolution();
						unsafe_handle = handle.DangerousGetHandle();
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.ws2_32_dll_PInvokes.GetAddrInfoW(
											unsafe_nodename, 
											unsafe_servicename, 
											pinned_hints, 
											&(unsafe_handle)
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
						global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
											handle, 
											unsafe_handle
										);
					}
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, WSASocketW, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_AddressFamily__System_Net_Primitives__AddressFamily__System_Net_Primitives, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketType__System_Net_Sockets__SocketType__System_Net_Sockets, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASocketW")]
		public static global::System.IntPtr WSASocketW(
					global::System_Net_Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System_Net_Sockets.SocketType__System_Net_Sockets socketType, 
					int protocolType, 
					global::System.IntPtr protocolInfo, 
					int group, 
					int flags)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.ws2_32_dll_PInvokes.WSASocketW(
								addressFamily, 
								socketType, 
								protocolType, 
								protocolInfo, 
								group, 
								flags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, closesocket, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "closesocket")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives closesocket(global::System.IntPtr socketHandle)
		{
			// Setup
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.ws2_32_dll_PInvokes.closesocket(socketHandle);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, WSASocketW__0, [fwd] [return] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_AddressFamily__System_Net_Primitives__AddressFamily__System_Net_Primitives, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketType__System_Net_Sockets__SocketType__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_ProtocolType__System_Net_Sockets__ProtocolType__System_Net_Sockets, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x00042D60] __Interop_Winsock_SocketConstructorFlags__System_Net_Sockets__Interop_Winsock_SocketConstructorFlags__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASocketW")]
		public static global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets WSASocketW__0(
					global::System_Net_Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System_Net_Sockets.SocketType__System_Net_Sockets socketType, 
					global::System_Net_Sockets.ProtocolType__System_Net_Sockets protocolType, 
					global::System.IntPtr protocolInfo, 
					uint group, 
					global::_.Interop_Winsock_SocketConstructorFlags__System_Net_Sockets flags)
		{
			// Setup
			global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.ws2_32_dll_PInvokes.WSASocketW__0(
								addressFamily, 
								socketType, 
								protocolType, 
								protocolInfo, 
								group, 
								flags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, WSAConnect, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSAConnect")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives WSAConnect(
					global::System.IntPtr socketHandle, 
					byte[] socketAddress, 
					int socketAddressSize, 
					global::System.IntPtr inBuffer, 
					global::System.IntPtr outBuffer, 
					global::System.IntPtr sQOS, 
					global::System.IntPtr gQOS)
		{
			// Setup
			byte* unsafe_socketAddress;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			fixed (byte* pinned_socketAddress = ((socketAddress != null 
						&& socketAddress.Length == 0) ? new byte[1] : socketAddress))
			{
				unsafe_socketAddress = (byte*)pinned_socketAddress;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.WSAConnect(
									socketHandle, 
									unsafe_socketAddress, 
									socketAddressSize, 
									inBuffer, 
									outBuffer, 
									sQOS, 
									gQOS
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, listen, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "listen")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives listen(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					int backlog)
		{
			// Setup
			bool addRefed = false;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.ws2_32_dll_PInvokes.listen(
								socketHandle.DangerousGetHandle(), 
								backlog
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, bind, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "bind")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives bind(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					byte[] socketAddress, 
					int socketAddressSize)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_socketAddress;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_socketAddress = ((socketAddress != null 
						&& socketAddress.Length == 0) ? new byte[1] : socketAddress))
			{
				unsafe_socketAddress = (byte*)pinned_socketAddress;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.bind(
									socketHandle.DangerousGetHandle(), 
									unsafe_socketAddress, 
									socketAddressSize
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, getsockopt, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getsockopt")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives getsockopt(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					out int optionValue, 
					ref int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (int* pinned_optionValue = &(optionValue))
				fixed (int* pinned_optionLength = &(optionLength))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.ws2_32_dll_PInvokes.getsockopt(
										socketHandle.DangerousGetHandle(), 
										optionLevel, 
										optionName, 
										pinned_optionValue, 
										pinned_optionLength
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, send, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "send")]
		public static int send(
					global::System.IntPtr socketHandle, 
					byte* pinnedBuffer, 
					int len, 
					global::System_Net_Sockets.SocketFlags__System_Net_Sockets socketFlags)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.ws2_32_dll_PInvokes.send(
								socketHandle, 
								((byte*)pinnedBuffer), 
								len, 
								socketFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, freeaddrinfo, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "freeaddrinfo")]
		public static void freeaddrinfo(global::System.IntPtr info)
		{
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			global::__Interop.ws2_32_dll_PInvokes.freeaddrinfo(info);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
		}

		// Signature, FreeAddrInfoExW, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] System_Net_Sockets_AddressInfoEx__System_Net_NameResolution___ptrSystem_Net_Sockets__AddressInfoEx__System_Net_NameResolution *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "FreeAddrInfoExW")]
		public static void FreeAddrInfoExW(global::System_Net_Sockets.AddressInfoEx__System_Net_NameResolution* pAddrInfo)
		{
			// Marshalling
			// Call to native method
			global::__Interop.ws2_32_dll_PInvokes.FreeAddrInfoExW(((global::System_Net_Sockets.AddressInfoEx__System_Net_NameResolution*)pAddrInfo));
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, WSASocketW__1, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_AddressFamily__System_Net_Primitives__AddressFamily__System_Net_Primitives, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Internals_SocketType__System_Net_NameResolution__SocketType__System_Net_NameResolution, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASocketW")]
		public static global::System.IntPtr WSASocketW__1(
					global::System_Net_Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System_Net_Internals.SocketType__System_Net_NameResolution socketType, 
					int protocolType, 
					global::System.IntPtr protocolInfo, 
					int group, 
					int flags)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.ws2_32_dll_PInvokes.WSASocketW__1(
								addressFamily, 
								socketType, 
								protocolType, 
								protocolInfo, 
								group, 
								flags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, closesocket__0, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "closesocket")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives closesocket__0(global::System.IntPtr socketHandle)
		{
			// Setup
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.ws2_32_dll_PInvokes.closesocket__0(socketHandle);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, gethostname, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [out] [EETypeRva:0x00041CF4] System_Text_StringBuilder__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "gethostname")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives gethostname(
					global::System.Text.StringBuilder hostName, 
					int bufferLength)
		{
			// Setup
			byte* unsafe_hostName = default(byte*);
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			try
			{
				// Marshalling
				if (hostName == null)
					unsafe_hostName = null;
				else
				{
					unsafe_hostName = (byte*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(hostName.Capacity * global::System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize 
										+ 2)));
					if (unsafe_hostName == null)
						throw new global::System.OutOfMemoryException();
				}
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.gethostname(
									unsafe_hostName, 
									bufferLength
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (hostName != null)
					global::System.Runtime.InteropServices.McgMarshal.AnsiStringToStringBuilder(
										unsafe_hostName, 
										hostName
									);
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_hostName != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_hostName);
			}
		}

		// Signature, getsockopt__0, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Winsock_Linger__System_Net_Sockets____Interop_Winsock_Linger__System_Net_Sockets, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getsockopt")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives getsockopt__0(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					out global::_.Interop_Winsock_Linger__System_Net_Sockets optionValue, 
					ref int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (global::_.Interop_Winsock_Linger__System_Net_Sockets* pinned_optionValue = &(optionValue))
				fixed (int* pinned_optionLength = &(optionLength))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.ws2_32_dll_PInvokes.getsockopt__0(
										socketHandle.DangerousGetHandle(), 
										optionLevel, 
										optionName, 
										pinned_optionValue, 
										pinned_optionLength
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, getsockopt__1, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Winsock_IPMulticastRequest__System_Net_Sockets____Interop_Winsock_IPMulticastRequest__System_Net_Sockets, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getsockopt")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives getsockopt__1(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					out global::_.Interop_Winsock_IPMulticastRequest__System_Net_Sockets optionValue, 
					ref int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (global::_.Interop_Winsock_IPMulticastRequest__System_Net_Sockets* pinned_optionValue = &(optionValue))
				fixed (int* pinned_optionLength = &(optionLength))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.ws2_32_dll_PInvokes.getsockopt__1(
										socketHandle.DangerousGetHandle(), 
										optionLevel, 
										optionName, 
										pinned_optionValue, 
										pinned_optionLength
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, getsockopt__2, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000421C0] __Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets____Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "getsockopt")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives getsockopt__2(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					out global::_.Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets optionValue, 
					ref int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::_.Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.UnsafeType unsafe_optionValue = default(global::_.Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.UnsafeType);
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			unsafe_optionValue = default(global::_.Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.UnsafeType);
			fixed (int* pinned_optionLength = &(optionLength))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.getsockopt__2(
									socketHandle.DangerousGetHandle(), 
									optionLevel, 
									optionName, 
									&(unsafe_optionValue), 
									pinned_optionLength
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			global::_.Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.Marshal__UnsafeToSafe(
								ref unsafe_optionValue, 
								out optionValue
							);
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, ioctlsocket__0, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "ioctlsocket")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives ioctlsocket__0(
					global::System.IntPtr handle, 
					int cmd, 
					ref int argp)
		{
			// Setup
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			fixed (int* pinned_argp = &(argp))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.ioctlsocket__0(
									handle, 
									cmd, 
									pinned_argp
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, setsockopt__2, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Winsock_Linger__System_Net_Sockets____Interop_Winsock_Linger__System_Net_Sockets, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt__2(
					global::System.IntPtr handle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					ref global::_.Interop_Winsock_Linger__System_Net_Sockets linger, 
					int optionLength)
		{
			// Setup
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			fixed (global::_.Interop_Winsock_Linger__System_Net_Sockets* pinned_linger = &(linger))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.setsockopt__2(
									handle, 
									optionLevel, 
									optionName, 
									pinned_linger, 
									optionLength
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, accept, [fwd] [return] [EETypeRva:0x000434A4] System_Net_Sockets_SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [out] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "accept")]
		public static global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets accept(
					global::System.IntPtr socketHandle, 
					byte[] socketAddress, 
					ref int socketAddressSize)
		{
			// Setup
			byte* unsafe_socketAddress;
			global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			fixed (byte* pinned_socketAddress = ((socketAddress != null 
						&& socketAddress.Length == 0) ? new byte[1] : socketAddress))
			{
				unsafe_socketAddress = (byte*)pinned_socketAddress;
				fixed (int* pinned_socketAddressSize = &(socketAddressSize))
				{
					__value = new global::System.Net.Sockets.SafeCloseSocket_InnerSafeCloseSocket__System_Net_Sockets();
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.ws2_32_dll_PInvokes.accept(
										socketHandle, 
										unsafe_socketAddress, 
										pinned_socketAddressSize
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
										__value, 
										unsafe___value
									);
				}
			}
			// Return
			return __value;
		}

		// Signature, GetAddrInfoExW, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] System_Net_Sockets_AddressInfoEx__System_Net_NameResolution__System_Net_Sockets__AddressInfoEx__System_Net_NameResolution, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_Net_Sockets_AddressInfoEx__System_Net_NameResolution___ptrSystem_Net_Sockets__AddressInfoEx__System_Net_NameResolution *, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] System_Threading_NativeOverlapped__System_Private_CoreLib__System_Threading__NativeOverlapped__System_Private_CoreLib, [fwd] [in] [EETypeRva:0x00041EA8] Interop_Winsock_LPLOOKUPSERVICE_COMPLETION_ROUTINE__System_Net_NameResolution____Interop_Winsock_LPLOOKUPSERVICE_COMPLETION_ROUTINE__System_Net_NameResolution, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "GetAddrInfoExW")]
		public static int GetAddrInfoExW(
					string pName, 
					string pServiceName, 
					int dwNamespace, 
					global::System.IntPtr lpNspId, 
					ref global::System_Net_Sockets.AddressInfoEx__System_Net_NameResolution pHints, 
					out global::System_Net_Sockets.AddressInfoEx__System_Net_NameResolution* ppResult, 
					global::System.IntPtr timeout, 
					ref global::System_Threading.NativeOverlapped__System_Private_CoreLib lpOverlapped, 
					global::Interop_Winsock_LPLOOKUPSERVICE_COMPLETION_ROUTINE__System_Net_NameResolution lpCompletionRoutine, 
					out global::System.IntPtr lpNameHandle)
		{
			// Setup
			ushort* unsafe_pName = default(ushort*);
			ushort* unsafe_pServiceName = default(ushort*);
			void* unsafe_lpCompletionRoutine = default(void*);
			int unsafe___value;
			try
			{
				// Marshalling
				fixed (char* pinned_pName = pName)
				{
					unsafe_pName = (ushort*)pinned_pName;
					fixed (char* pinned_pServiceName = pServiceName)
					{
						unsafe_pServiceName = (ushort*)pinned_pServiceName;
						fixed (global::System_Net_Sockets.AddressInfoEx__System_Net_NameResolution* pinned_pHints = &(pHints))
							fixed (global::System_Net_Sockets.AddressInfoEx__System_Net_NameResolution** pinned_ppResult = &(ppResult))
								fixed (global::System_Threading.NativeOverlapped__System_Private_CoreLib* pinned_lpOverlapped = &(lpOverlapped))
								{
									unsafe_lpCompletionRoutine = (void*)global::System.Runtime.InteropServices.McgMarshal.GetStubForPInvokeDelegate(
														global::System.Runtime.InteropServices.TypeOfHelper.RuntimeTypeHandleOf("Interop+Winsock+LPLOOKUPSERVICE_COMPLETION_ROUTINE,System.Net.NameResolution, Version=4.1.1.0, Culture=neutral, " +
																"PublicKeyToken=b03f5f7f11d50a3a"), 
														lpCompletionRoutine
													);
									fixed (global::System.IntPtr* pinned_lpNameHandle = &(lpNameHandle))
									{
										global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
										// Call to native method
										unsafe___value = global::__Interop.ws2_32_dll_PInvokes.GetAddrInfoExW(
															unsafe_pName, 
															unsafe_pServiceName, 
															dwNamespace, 
															lpNspId, 
															pinned_pHints, 
															pinned_ppResult, 
															timeout, 
															pinned_lpOverlapped, 
															unsafe_lpCompletionRoutine, 
															pinned_lpNameHandle
														);
										global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
										global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
									}
								}
					}
				}
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.GC.KeepAlive(lpCompletionRoutine);
			}
		}

		// Signature, WSARecv, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_Net_Sockets_WSABuffer__System_Net_Sockets___ptrSystem_Net_Sockets__WSABuffer__System_Net_Sockets *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D60] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [EETypeRva:0x000419B0] System_Threading_NativeOverlapped__System_Private_CoreLib___ptrSystem_Threading__NativeOverlapped__System_Private_CoreLib *, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSARecv")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives WSARecv(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.WSABuffer__System_Net_Sockets* buffer, 
					int bufferCount, 
					out int bytesTransferred, 
					ref global::System_Net_Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System_Threading.NativeOverlapped__System_Private_CoreLib* overlapped, 
					global::System.IntPtr completionRoutine)
		{
			// Setup
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			fixed (int* pinned_bytesTransferred = &(bytesTransferred))
				fixed (global::System_Net_Sockets.SocketFlags__System_Net_Sockets* pinned_socketFlags = &(socketFlags))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.ws2_32_dll_PInvokes.WSARecv(
										socketHandle, 
										((global::System_Net_Sockets.WSABuffer__System_Net_Sockets*)buffer), 
										bufferCount, 
										pinned_bytesTransferred, 
										pinned_socketFlags, 
										((global::System_Threading.NativeOverlapped__System_Private_CoreLib*)overlapped), 
										completionRoutine
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			// Return
			return unsafe___value;
		}

		// Signature, WSASend, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_Net_Sockets_WSABuffer__System_Net_Sockets___ptrSystem_Net_Sockets__WSABuffer__System_Net_Sockets *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, [fwd] [in] [EETypeRva:0x000419B0] System_Threading_NativeOverlapped__System_Private_CoreLib___ptrSystem_Threading__NativeOverlapped__System_Private_CoreLib *, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSASend")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives WSASend(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.WSABuffer__System_Net_Sockets* buffers, 
					int bufferCount, 
					out int bytesTransferred, 
					global::System_Net_Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System_Threading.NativeOverlapped__System_Private_CoreLib* overlapped, 
					global::System.IntPtr completionRoutine)
		{
			// Setup
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			fixed (int* pinned_bytesTransferred = &(bytesTransferred))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.WSASend(
									socketHandle, 
									((global::System_Net_Sockets.WSABuffer__System_Net_Sockets*)buffers), 
									bufferCount, 
									pinned_bytesTransferred, 
									socketFlags, 
									((global::System_Threading.NativeOverlapped__System_Private_CoreLib*)overlapped), 
									completionRoutine
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, GetNameInfoW, [fwd] [return] [EETypeRva:0x00042D60] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [EETypeRva:0x00041CF4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [EETypeRva:0x00041CF4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.NameResolution, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "GetNameInfoW")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives GetNameInfoW(
					byte[] sa, 
					int salen, 
					global::System.Text.StringBuilder host, 
					int hostlen, 
					global::System.Text.StringBuilder serv, 
					int servlen, 
					int flags)
		{
			// Setup
			byte* unsafe_sa;
			ushort* unsafe_host = default(ushort*);
			ushort* unsafe_serv = default(ushort*);
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			try
			{
				// Marshalling
				fixed (byte* pinned_sa = ((sa != null 
							&& sa.Length == 0) ? new byte[1] : sa))
				{
					unsafe_sa = (byte*)pinned_sa;
					if (host == null)
						unsafe_host = null;
					else
					{
						unsafe_host = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(host.Capacity * 2 
											+ 2)));
						if (unsafe_host == null)
							throw new global::System.OutOfMemoryException();
					}
					if (serv == null)
						unsafe_serv = null;
					else
					{
						unsafe_serv = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(serv.Capacity * 2 
											+ 2)));
						if (unsafe_serv == null)
							throw new global::System.OutOfMemoryException();
					}
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.ws2_32_dll_PInvokes.GetNameInfoW(
										unsafe_sa, 
										salen, 
										unsafe_host, 
										hostlen, 
										unsafe_serv, 
										servlen, 
										flags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					if (serv != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_serv, 
											serv
										);
					if (host != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_host, 
											host
										);
				}
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_host != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_host);
				if (unsafe_serv != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_serv);
			}
		}
	}

	/// <summary>
	/// P/Invoke class for module 'OleAut32'
	/// </summary>
	public unsafe static partial class OleAut32
	{
		// Signature, SysFreeString, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.StackTraceGenerator, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.LightweightInterop.MarshalExtensions", "SysFreeString")]
		public static void SysFreeString(global::System.IntPtr bstr)
		{
			// Marshalling
			// Call to native method
			global::__Interop.OleAut32_PInvokes.SysFreeString(bstr);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'ncrypt.dll'
	/// </summary>
	public unsafe static partial class ncrypt_dll
	{
		// Signature, NCryptOpenKey, [fwd] [return] [EETypeRva:0x00042D60] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeNCryptProviderHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] System_Security_Cryptography_CngKeyOpenOptions__System_Security_Cryptography_Cng__CngKeyOpenOptions__System_Security_Cryptography_Cng, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptOpenKey")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenKey(
					global::Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle__System_Security_Cryptography_Cng hProvider, 
					out global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng phKey, 
					string pszKeyName, 
					int dwLegacyKeySpec, 
					global::System_Security_Cryptography.CngKeyOpenOptions__System_Security_Cryptography_Cng dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_phKey;
			ushort* unsafe_pszKeyName = default(ushort*);
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hProvider.DangerousAddRef(ref addRefed);
			phKey = new global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng();
			unsafe_phKey = phKey.DangerousGetHandle();
			fixed (char* pinned_pszKeyName = pszKeyName)
			{
				unsafe_pszKeyName = (ushort*)pinned_pszKeyName;
				// Call to native method
				unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptOpenKey(
									hProvider.DangerousGetHandle(), 
									&(unsafe_phKey), 
									unsafe_pszKeyName, 
									dwLegacyKeySpec, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phKey, 
								unsafe_phKey
							);
			if (addRefed)
				hProvider.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptDeleteKey, [fwd] [return] [EETypeRva:0x00042D60] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptDeleteKey")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptDeleteKey(
					global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng hKey, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptDeleteKey(
								hKey.DangerousGetHandle(), 
								dwFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptOpenStorageProvider, [fwd] [return] [EETypeRva:0x00042D60] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeNCryptProviderHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptOpenStorageProvider")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenStorageProvider(
					out global::Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle__System_Security_Cryptography_Cng phProvider, 
					string pszProviderName, 
					int dwFlags)
		{
			// Setup
			global::System.IntPtr unsafe_phProvider;
			ushort* unsafe_pszProviderName = default(ushort*);
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			phProvider = new global::Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle__System_Security_Cryptography_Cng();
			unsafe_phProvider = phProvider.DangerousGetHandle();
			fixed (char* pinned_pszProviderName = pszProviderName)
			{
				unsafe_pszProviderName = (ushort*)pinned_pszProviderName;
				// Call to native method
				unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptOpenStorageProvider(
									&(unsafe_phProvider), 
									unsafe_pszProviderName, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phProvider, 
								unsafe_phProvider
							);
			// Return
			return unsafe___value;
		}

		// Signature, NCryptFreeObject, [fwd] [return] [EETypeRva:0x00042D60] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptFreeObject")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptFreeObject(global::System.IntPtr hObject)
		{
			// Setup
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptFreeObject(hObject);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptImportKey, [fwd] [return] [EETypeRva:0x00042D60] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeNCryptProviderHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptImportKey")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptImportKey(
					global::Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle__System_Security_Cryptography_Cng hProvider, 
					global::System.IntPtr hImportKey, 
					string pszBlobType, 
					global::System.IntPtr pParameterList, 
					out global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng phKey, 
					byte[] pbData, 
					int cbData, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszBlobType = default(ushort*);
			global::System.IntPtr unsafe_phKey;
			byte* unsafe_pbData;
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hProvider.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszBlobType = pszBlobType)
			{
				unsafe_pszBlobType = (ushort*)pinned_pszBlobType;
				phKey = new global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng();
				unsafe_phKey = phKey.DangerousGetHandle();
				fixed (byte* pinned_pbData = ((pbData != null 
							&& pbData.Length == 0) ? new byte[1] : pbData))
				{
					unsafe_pbData = (byte*)pinned_pbData;
					// Call to native method
					unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptImportKey(
										hProvider.DangerousGetHandle(), 
										hImportKey, 
										unsafe_pszBlobType, 
										pParameterList, 
										&(unsafe_phKey), 
										unsafe_pbData, 
										cbData, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				}
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									phKey, 
									unsafe_phKey
								);
			}
			if (addRefed)
				hProvider.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptGetProperty, [fwd] [return] [EETypeRva:0x00042D60] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeNCryptHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [out] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] System_Security_Cryptography_CngPropertyOptions__System_Security_Cryptography_Cng__CngPropertyOptions__System_Security_Cryptography_Cng, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptGetProperty")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptGetProperty(
					global::Microsoft.Win32.SafeHandles.SafeNCryptHandle__System_Security_Cryptography_Cng hObject, 
					string pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					global::System_Security_Cryptography.CngPropertyOptions__System_Security_Cryptography_Cng dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				fixed (int* pinned_pcbResult = &(pcbResult))
				{
					// Call to native method
					unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptGetProperty(
										hObject.DangerousGetHandle(), 
										unsafe_pszProperty, 
										((void*)pbOutput), 
										cbOutput, 
										pinned_pcbResult, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				}
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptSetProperty, [fwd] [return] [EETypeRva:0x00042D60] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeNCryptHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] System_Security_Cryptography_CngPropertyOptions__System_Security_Cryptography_Cng__CngPropertyOptions__System_Security_Cryptography_Cng, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptSetProperty")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptSetProperty(
					global::Microsoft.Win32.SafeHandles.SafeNCryptHandle__System_Security_Cryptography_Cng hObject, 
					string pszProperty, 
					void* pbInput, 
					int cbInput, 
					global::System_Security_Cryptography.CngPropertyOptions__System_Security_Cryptography_Cng dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				// Call to native method
				unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptSetProperty(
									hObject.DangerousGetHandle(), 
									unsafe_pszProperty, 
									((void*)pbInput), 
									cbInput, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-winrt-robuffer-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_winrt_robuffer_l1_1_0_dll
	{
		// Signature, RoGetBufferMarshaler, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043660] System_Runtime_InteropServices_IMarshal__System_Runtime_WindowsRuntime__System_Runtime_InteropServices__IMarshal__System_Runtime_WindowsRuntime *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Runtime.WindowsRuntime, Version=4.0.14.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "Interop+mincore", "RoGetBufferMarshaler")]
		public static int RoGetBufferMarshaler(out global::System_Runtime_InteropServices.IMarshal__System_Runtime_WindowsRuntime bufferMarshalerPtr)
		{
			// Setup
			void* unsafe_bufferMarshalerPtr = default(void*);
			int unsafe___value;
			try
			{
				// Marshalling
				unsafe_bufferMarshalerPtr = null;
				// Call to native method
				unsafe___value = global::__Interop.api_ms_win_core_winrt_robuffer_l1_1_0_dll_PInvokes.RoGetBufferMarshaler(&(unsafe_bufferMarshalerPtr));
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				bufferMarshalerPtr = (global::System_Runtime_InteropServices.IMarshal__System_Runtime_WindowsRuntime)global::System.Runtime.InteropServices.McgMarshal.ComInterfaceToObject(
									((global::System.IntPtr)unsafe_bufferMarshalerPtr), 
									global::System.Runtime.InteropServices.TypeOfHelper.RuntimeTypeHandleOf("System.Runtime.InteropServices.IMarshal,System.Runtime.WindowsRuntime, Version=4.0.14.0, Culture=neutral, Public" +
											"KeyToken=b77a5c561934e089")
								);
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.McgMarshal.ComSafeRelease(new global::System.IntPtr(((void*)unsafe_bufferMarshalerPtr)));
			}
		}
	}

	/// <summary>
	/// P/Invoke class for module 'iphlpapi.dll'
	/// </summary>
	public unsafe static partial class iphlpapi_dll
	{
		// Signature, GetNetworkParams, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLocalAllocHandle__System_Net_Primitives____w64 int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Primitives, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+IpHlpApi", "GetNetworkParams")]
		public static uint GetNetworkParams(
					global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Net_Primitives pFixedInfo, 
					ref uint pOutBufLen)
		{
			// Setup
			bool addRefed = false;
			uint unsafe___value;
			// Marshalling
			pFixedInfo.DangerousAddRef(ref addRefed);
			fixed (uint* pinned_pOutBufLen = &(pOutBufLen))
			{
				// Call to native method
				unsafe___value = global::__Interop.iphlpapi_dll_PInvokes.GetNetworkParams(
									pFixedInfo.DangerousGetHandle(), 
									pinned_pOutBufLen
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			if (addRefed)
				pFixedInfo.DangerousRelease();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'BCrypt.dll'
	/// </summary>
	public unsafe static partial class BCrypt_dll
	{
		// Signature, BCryptExportKey, [fwd] [return] [EETypeRva:0x00042D60] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeBCryptKeyHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [out] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+BCrypt", "BCryptExportKey")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptExportKey(
					global::Microsoft.Win32.SafeHandles.SafeBCryptKeyHandle__System_Security_Cryptography_X509Certificates hKey, 
					global::System.IntPtr hExportKey, 
					string pszBlobType, 
					byte[] pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszBlobType = default(ushort*);
			byte* unsafe_pbOutput;
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszBlobType = pszBlobType)
			{
				unsafe_pszBlobType = (ushort*)pinned_pszBlobType;
				fixed (byte* pinned_pbOutput = ((pbOutput != null 
							&& pbOutput.Length == 0) ? new byte[1] : pbOutput))
				{
					unsafe_pbOutput = (byte*)pinned_pbOutput;
					fixed (int* pinned_pcbResult = &(pcbResult))
					{
						// Call to native method
						unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptExportKey(
											hKey.DangerousGetHandle(), 
											hExportKey, 
											unsafe_pszBlobType, 
											unsafe_pbOutput, 
											cbOutput, 
											pinned_pcbResult, 
											dwFlags
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					}
				}
			}
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptGetProperty, [fwd] [return] [EETypeRva:0x00042D60] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeBCryptHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+BCrypt", "BCryptGetProperty")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptGetProperty(
					global::Microsoft.Win32.SafeHandles.SafeBCryptHandle__System_Security_Cryptography_X509Certificates hObject, 
					string pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				fixed (int* pinned_pcbResult = &(pcbResult))
				{
					// Call to native method
					unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptGetProperty(
										hObject.DangerousGetHandle(), 
										unsafe_pszProperty, 
										((void*)pbOutput), 
										cbOutput, 
										pinned_pcbResult, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				}
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptDestroyKey, [fwd] [return] [EETypeRva:0x00042D60] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+BCrypt", "BCryptDestroyKey")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptDestroyKey(global::System.IntPtr hKey)
		{
			// Setup
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptDestroyKey(hKey);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptCreateHash, [fwd] [return] [EETypeRva:0x00042D60] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeBCryptAlgorithmHandle__System_Security_Cryptography_Algorithms____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeBCryptHashHandle__System_Security_Cryptography_Algorithms____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [EETypeRva:0x00042A40] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] __Interop_BCrypt_BCryptCreateHashFlags__System_Security_Cryptography_Algorithms__Interop_BCrypt_BCryptCreateHashFlags__System_Security_Cryptography_Algorithms, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptCreateHash")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptCreateHash(
					global::Microsoft.Win32.SafeHandles.SafeBCryptAlgorithmHandle__System_Security_Cryptography_Algorithms hAlgorithm, 
					out global::Microsoft.Win32.SafeHandles.SafeBCryptHashHandle__System_Security_Cryptography_Algorithms phHash, 
					global::System.IntPtr pbHashObject, 
					int cbHashObject, 
					byte[] pbSecret, 
					int cbSecret, 
					global::_.Interop_BCrypt_BCryptCreateHashFlags__System_Security_Cryptography_Algorithms dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_phHash;
			byte* unsafe_pbSecret;
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			hAlgorithm.DangerousAddRef(ref addRefed);
			phHash = new global::Microsoft.Win32.SafeHandles.SafeBCryptHashHandle__System_Security_Cryptography_Algorithms();
			unsafe_phHash = phHash.DangerousGetHandle();
			fixed (byte* pinned_pbSecret = ((pbSecret != null 
						&& pbSecret.Length == 0) ? new byte[1] : pbSecret))
			{
				unsafe_pbSecret = (byte*)pinned_pbSecret;
				// Call to native method
				unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptCreateHash(
									hAlgorithm.DangerousGetHandle(), 
									&(unsafe_phHash), 
									pbHashObject, 
									cbHashObject, 
									unsafe_pbSecret, 
									cbSecret, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phHash, 
								unsafe_phHash
							);
			if (addRefed)
				hAlgorithm.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptGetProperty__0, [fwd] [return] [EETypeRva:0x00042D60] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeBCryptHandle__System_Security_Cryptography_Algorithms____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptGetProperty")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptGetProperty__0(
					global::Microsoft.Win32.SafeHandles.SafeBCryptHandle__System_Security_Cryptography_Algorithms hObject, 
					string pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				fixed (int* pinned_pcbResult = &(pcbResult))
				{
					// Call to native method
					unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptGetProperty__0(
										hObject.DangerousGetHandle(), 
										unsafe_pszProperty, 
										((void*)pbOutput), 
										cbOutput, 
										pinned_pcbResult, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				}
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptOpenAlgorithmProvider, [fwd] [return] [EETypeRva:0x00042D60] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeBCryptAlgorithmHandle__System_Security_Cryptography_Algorithms____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x00042D60] __Interop_BCrypt_BCryptOpenAlgorithmProviderFlags__System_Security_Cryptography_Algorithms__Interop_BCrypt_BCryptOpenAlgorithmProviderFlags__System_Security_Cryptography_Algorithms, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptOpenAlgorithmProvider")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptOpenAlgorithmProvider(
					out global::Microsoft.Win32.SafeHandles.SafeBCryptAlgorithmHandle__System_Security_Cryptography_Algorithms phAlgorithm, 
					string pszAlgId, 
					string pszImplementation, 
					global::_.Interop_BCrypt_BCryptOpenAlgorithmProviderFlags__System_Security_Cryptography_Algorithms dwFlags)
		{
			// Setup
			global::System.IntPtr unsafe_phAlgorithm;
			ushort* unsafe_pszAlgId = default(ushort*);
			ushort* unsafe_pszImplementation = default(ushort*);
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			phAlgorithm = new global::Microsoft.Win32.SafeHandles.SafeBCryptAlgorithmHandle__System_Security_Cryptography_Algorithms();
			unsafe_phAlgorithm = phAlgorithm.DangerousGetHandle();
			fixed (char* pinned_pszAlgId = pszAlgId)
			{
				unsafe_pszAlgId = (ushort*)pinned_pszAlgId;
				fixed (char* pinned_pszImplementation = pszImplementation)
				{
					unsafe_pszImplementation = (ushort*)pinned_pszImplementation;
					// Call to native method
					unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptOpenAlgorithmProvider(
										&(unsafe_phAlgorithm), 
										unsafe_pszAlgId, 
										unsafe_pszImplementation, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				}
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phAlgorithm, 
								unsafe_phAlgorithm
							);
			// Return
			return unsafe___value;
		}

		// Signature, BCryptCloseAlgorithmProvider, [fwd] [return] [EETypeRva:0x00042D60] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptCloseAlgorithmProvider")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptCloseAlgorithmProvider(
					global::System.IntPtr hAlgorithm, 
					int dwFlags)
		{
			// Setup
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptCloseAlgorithmProvider(
								hAlgorithm, 
								dwFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptDestroyHash, [fwd] [return] [EETypeRva:0x00042D60] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptDestroyHash")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptDestroyHash(global::System.IntPtr hHash)
		{
			// Setup
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptDestroyHash(hHash);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptGenRandom, [fwd] [return] [EETypeRva:0x00042D60] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] byte__unsigned char, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptGenRandom")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptGenRandom(
					global::System.IntPtr hAlgorithm, 
					ref byte pbBuffer, 
					int cbBuffer, 
					int dwFlags)
		{
			// Setup
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			fixed (byte* pinned_pbBuffer = &(pbBuffer))
			{
				// Call to native method
				unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptGenRandom(
									hAlgorithm, 
									pinned_pbBuffer, 
									cbBuffer, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'sspicli.dll'
	/// </summary>
	public unsafe static partial class sspicli_dll
	{
		// Signature, LsaGetLogonSessionData, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_LUID__System_Security_Principal_Windows____Interop_LUID__System_Security_Principal_Windows, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeLsaReturnBufferHandle__System_Security_Principal_Windows____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "LsaGetLogonSessionData")]
		public static int LsaGetLogonSessionData(
					ref global::_.Interop_LUID__System_Security_Principal_Windows LogonId, 
					ref global::Microsoft.Win32.SafeHandles.SafeLsaReturnBufferHandle__System_Security_Principal_Windows ppLogonSessionData)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_ppLogonSessionData;
			global::Microsoft.Win32.SafeHandles.SafeLsaReturnBufferHandle__System_Security_Principal_Windows out_ppLogonSessionData;
			global::System.IntPtr prev_unsafe_ppLogonSessionData;
			int unsafe___value;
			// Marshalling
			fixed (global::_.Interop_LUID__System_Security_Principal_Windows* pinned_LogonId = &(LogonId))
			{
				ppLogonSessionData.DangerousAddRef(ref addRefed);
				unsafe_ppLogonSessionData = ppLogonSessionData.DangerousGetHandle();
				prev_unsafe_ppLogonSessionData = unsafe_ppLogonSessionData;
				out_ppLogonSessionData = new global::Microsoft.Win32.SafeHandles.SafeLsaReturnBufferHandle__System_Security_Principal_Windows();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.sspicli_dll_PInvokes.LsaGetLogonSessionData(
									pinned_LogonId, 
									&(unsafe_ppLogonSessionData)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (addRefed)
					ppLogonSessionData.DangerousRelease();
				if (prev_unsafe_ppLogonSessionData != unsafe_ppLogonSessionData)
				{
					global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
										out_ppLogonSessionData, 
										unsafe_ppLogonSessionData
									);
					ppLogonSessionData = out_ppLogonSessionData;
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, LsaFreeReturnBuffer, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "LsaFreeReturnBuffer")]
		public static int LsaFreeReturnBuffer(global::System.IntPtr handle)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.sspicli_dll_PInvokes.LsaFreeReturnBuffer(handle);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, EncryptMessage, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_CredHandle__System_Net_Security____Interop_SspiCli_CredHandle__System_Net_Security, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_SecBufferDesc__System_Net_Security____Interop_SspiCli_SecBufferDesc__System_Net_Security, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "EncryptMessage")]
		public static int EncryptMessage(
					ref global::_.Interop_SspiCli_CredHandle__System_Net_Security contextHandle, 
					uint qualityOfProtection, 
					ref global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security inputOutput, 
					uint sequenceNumber)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::_.Interop_SspiCli_CredHandle__System_Net_Security* pinned_contextHandle = &(contextHandle))
				fixed (global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* pinned_inputOutput = &(inputOutput))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.sspicli_dll_PInvokes.EncryptMessage(
										pinned_contextHandle, 
										qualityOfProtection, 
										pinned_inputOutput, 
										sequenceNumber
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			// Return
			return unsafe___value;
		}

		// Signature, DecryptMessage, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_CredHandle__System_Net_Security____Interop_SspiCli_CredHandle__System_Net_Security, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_SecBufferDesc__System_Net_Security____Interop_SspiCli_SecBufferDesc__System_Net_Security, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] uint___ptrunsigned int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "DecryptMessage")]
		public static int DecryptMessage(
					ref global::_.Interop_SspiCli_CredHandle__System_Net_Security contextHandle, 
					ref global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security inputOutput, 
					uint sequenceNumber, 
					uint* qualityOfProtection)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::_.Interop_SspiCli_CredHandle__System_Net_Security* pinned_contextHandle = &(contextHandle))
				fixed (global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* pinned_inputOutput = &(inputOutput))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.sspicli_dll_PInvokes.DecryptMessage(
										pinned_contextHandle, 
										pinned_inputOutput, 
										sequenceNumber, 
										((uint*)qualityOfProtection)
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			// Return
			return unsafe___value;
		}

		// Signature, EnumerateSecurityPackagesW, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] System_Net_Security_SafeFreeContextBuffer_SECURITY__System_Net_Security____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "EnumerateSecurityPackagesW")]
		public static int EnumerateSecurityPackagesW(
					out int pkgnum, 
					out global::System.Net.Security.SafeFreeContextBuffer_SECURITY__System_Net_Security handle)
		{
			// Setup
			global::System.IntPtr unsafe_handle;
			int unsafe___value;
			// Marshalling
			fixed (int* pinned_pkgnum = &(pkgnum))
			{
				handle = new global::System.Net.Security.SafeFreeContextBuffer_SECURITY__System_Net_Security();
				unsafe_handle = handle.DangerousGetHandle();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.sspicli_dll_PInvokes.EnumerateSecurityPackagesW(
									pinned_pkgnum, 
									&(unsafe_handle)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									handle, 
									unsafe_handle
								);
			}
			// Return
			return unsafe___value;
		}

		// Signature, QueryContextAttributesW, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_CredHandle__System_Net_Security____Interop_SspiCli_CredHandle__System_Net_Security, [fwd] [in] [EETypeRva:0x00042D60] __Interop_SspiCli_ContextAttribute__System_Net_Security__Interop_SspiCli_ContextAttribute__System_Net_Security, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "QueryContextAttributesW")]
		public static int QueryContextAttributesW(
					ref global::_.Interop_SspiCli_CredHandle__System_Net_Security contextHandle, 
					global::_.Interop_SspiCli_ContextAttribute__System_Net_Security attribute, 
					void* buffer)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::_.Interop_SspiCli_CredHandle__System_Net_Security* pinned_contextHandle = &(contextHandle))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.sspicli_dll_PInvokes.QueryContextAttributesW(
									pinned_contextHandle, 
									attribute, 
									((void*)buffer)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, ApplyControlToken, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_SecBufferDesc__System_Net_Security____Interop_SspiCli_SecBufferDesc__System_Net_Security, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "ApplyControlToken")]
		public static int ApplyControlToken(
					void* inContextPtr, 
					ref global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security inputBuffers)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* pinned_inputBuffers = &(inputBuffers))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.sspicli_dll_PInvokes.ApplyControlToken(
									((void*)inContextPtr), 
									pinned_inputBuffers
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, FreeContextBuffer, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "FreeContextBuffer")]
		public static int FreeContextBuffer(global::System.IntPtr contextBuffer)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.sspicli_dll_PInvokes.FreeContextBuffer(contextBuffer);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, AcceptSecurityContext, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_CredHandle__System_Net_Security____Interop_SspiCli_CredHandle__System_Net_Security, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [EETypeRva:0x000419B0] __Interop_SspiCli_SecBufferDesc__System_Net_Security___ptr__Interop_SspiCli_SecBufferDesc__System_Net_Security *, [fwd] [in] [EETypeRva:0x00042D60] __Interop_SspiCli_ContextFlags__System_Net_Security__Interop_SspiCli_ContextFlags__System_Net_Security, [fwd] [in] [EETypeRva:0x00042D60] __Interop_SspiCli_Endianness__System_Net_Security__Interop_SspiCli_Endianness__System_Net_Security, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_CredHandle__System_Net_Security____Interop_SspiCli_CredHandle__System_Net_Security, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_SecBufferDesc__System_Net_Security____Interop_SspiCli_SecBufferDesc__System_Net_Security, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D60] __Interop_SspiCli_ContextFlags__System_Net_Security__Interop_SspiCli_ContextFlags__System_Net_Security, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] long____int64, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "AcceptSecurityContext")]
		public static int AcceptSecurityContext(
					ref global::_.Interop_SspiCli_CredHandle__System_Net_Security credentialHandle, 
					void* inContextPtr, 
					global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* inputBuffer, 
					global::_.Interop_SspiCli_ContextFlags__System_Net_Security inFlags, 
					global::_.Interop_SspiCli_Endianness__System_Net_Security endianness, 
					ref global::_.Interop_SspiCli_CredHandle__System_Net_Security outContextPtr, 
					ref global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security outputBuffer, 
					ref global::_.Interop_SspiCli_ContextFlags__System_Net_Security attributes, 
					out long timeStamp)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::_.Interop_SspiCli_CredHandle__System_Net_Security* pinned_credentialHandle = &(credentialHandle))
				fixed (global::_.Interop_SspiCli_CredHandle__System_Net_Security* pinned_outContextPtr = &(outContextPtr))
					fixed (global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* pinned_outputBuffer = &(outputBuffer))
						fixed (global::_.Interop_SspiCli_ContextFlags__System_Net_Security* pinned_attributes = &(attributes))
							fixed (long* pinned_timeStamp = &(timeStamp))
							{
								global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
								// Call to native method
								unsafe___value = global::__Interop.sspicli_dll_PInvokes.AcceptSecurityContext(
													pinned_credentialHandle, 
													((void*)inContextPtr), 
													((global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security*)inputBuffer), 
													inFlags, 
													endianness, 
													pinned_outContextPtr, 
													pinned_outputBuffer, 
													pinned_attributes, 
													pinned_timeStamp
												);
								global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
								global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
							}
			// Return
			return unsafe___value;
		}

		// Signature, DeleteSecurityContext, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_CredHandle__System_Net_Security____Interop_SspiCli_CredHandle__System_Net_Security, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "DeleteSecurityContext")]
		public static int DeleteSecurityContext(ref global::_.Interop_SspiCli_CredHandle__System_Net_Security handlePtr)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::_.Interop_SspiCli_CredHandle__System_Net_Security* pinned_handlePtr = &(handlePtr))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.sspicli_dll_PInvokes.DeleteSecurityContext(pinned_handlePtr);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, InitializeSecurityContextW, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_CredHandle__System_Net_Security____Interop_SspiCli_CredHandle__System_Net_Security, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x00042D60] __Interop_SspiCli_ContextFlags__System_Net_Security__Interop_SspiCli_ContextFlags__System_Net_Security, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042D60] __Interop_SspiCli_Endianness__System_Net_Security__Interop_SspiCli_Endianness__System_Net_Security, [fwd] [in] [EETypeRva:0x000419B0] __Interop_SspiCli_SecBufferDesc__System_Net_Security___ptr__Interop_SspiCli_SecBufferDesc__System_Net_Security *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_CredHandle__System_Net_Security____Interop_SspiCli_CredHandle__System_Net_Security, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_SecBufferDesc__System_Net_Security____Interop_SspiCli_SecBufferDesc__System_Net_Security, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D60] __Interop_SspiCli_ContextFlags__System_Net_Security__Interop_SspiCli_ContextFlags__System_Net_Security, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] long____int64, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "InitializeSecurityContextW")]
		public static int InitializeSecurityContextW(
					ref global::_.Interop_SspiCli_CredHandle__System_Net_Security credentialHandle, 
					void* inContextPtr, 
					byte* targetName, 
					global::_.Interop_SspiCli_ContextFlags__System_Net_Security inFlags, 
					int reservedI, 
					global::_.Interop_SspiCli_Endianness__System_Net_Security endianness, 
					global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* inputBuffer, 
					int reservedII, 
					ref global::_.Interop_SspiCli_CredHandle__System_Net_Security outContextPtr, 
					ref global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security outputBuffer, 
					ref global::_.Interop_SspiCli_ContextFlags__System_Net_Security attributes, 
					out long timeStamp)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::_.Interop_SspiCli_CredHandle__System_Net_Security* pinned_credentialHandle = &(credentialHandle))
				fixed (global::_.Interop_SspiCli_CredHandle__System_Net_Security* pinned_outContextPtr = &(outContextPtr))
					fixed (global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* pinned_outputBuffer = &(outputBuffer))
						fixed (global::_.Interop_SspiCli_ContextFlags__System_Net_Security* pinned_attributes = &(attributes))
							fixed (long* pinned_timeStamp = &(timeStamp))
							{
								global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
								// Call to native method
								unsafe___value = global::__Interop.sspicli_dll_PInvokes.InitializeSecurityContextW(
													pinned_credentialHandle, 
													((void*)inContextPtr), 
													((byte*)targetName), 
													inFlags, 
													reservedI, 
													endianness, 
													((global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security*)inputBuffer), 
													reservedII, 
													pinned_outContextPtr, 
													pinned_outputBuffer, 
													pinned_attributes, 
													pinned_timeStamp
												);
								global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
								global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
							}
			// Return
			return unsafe___value;
		}

		// Signature, AcquireCredentialsHandleW, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_SCHANNEL_CRED__System_Net_Security____Interop_SspiCli_SCHANNEL_CRED__System_Net_Security, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_CredHandle__System_Net_Security____Interop_SspiCli_CredHandle__System_Net_Security, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] long____int64, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "AcquireCredentialsHandleW")]
		public static int AcquireCredentialsHandleW(
					string principal, 
					string moduleName, 
					int usage, 
					void* logonID, 
					ref global::_.Interop_SspiCli_SCHANNEL_CRED__System_Net_Security authData, 
					void* keyCallback, 
					void* keyArgument, 
					ref global::_.Interop_SspiCli_CredHandle__System_Net_Security handlePtr, 
					out long timeStamp)
		{
			// Setup
			ushort* unsafe_principal = default(ushort*);
			ushort* unsafe_moduleName = default(ushort*);
			int unsafe___value;
			// Marshalling
			fixed (char* pinned_principal = principal)
			{
				unsafe_principal = (ushort*)pinned_principal;
				fixed (char* pinned_moduleName = moduleName)
				{
					unsafe_moduleName = (ushort*)pinned_moduleName;
					fixed (global::_.Interop_SspiCli_SCHANNEL_CRED__System_Net_Security* pinned_authData = &(authData))
						fixed (global::_.Interop_SspiCli_CredHandle__System_Net_Security* pinned_handlePtr = &(handlePtr))
							fixed (long* pinned_timeStamp = &(timeStamp))
							{
								global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
								// Call to native method
								unsafe___value = global::__Interop.sspicli_dll_PInvokes.AcquireCredentialsHandleW(
													unsafe_principal, 
													unsafe_moduleName, 
													usage, 
													((void*)logonID), 
													pinned_authData, 
													((void*)keyCallback), 
													((void*)keyArgument), 
													pinned_handlePtr, 
													pinned_timeStamp
												);
								global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
								global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
							}
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, FreeCredentialsHandle, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_SspiCli_CredHandle__System_Net_Security____Interop_SspiCli_CredHandle__System_Net_Security, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+SspiCli", "FreeCredentialsHandle")]
		public static int FreeCredentialsHandle(ref global::_.Interop_SspiCli_CredHandle__System_Net_Security handlePtr)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::_.Interop_SspiCli_CredHandle__System_Net_Security* pinned_handlePtr = &(handlePtr))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.sspicli_dll_PInvokes.FreeCredentialsHandle(pinned_handlePtr);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}
	}

	public unsafe static partial class _MRT__PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static uint RhpGetFuncEvalParameterBufferSize();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static uint RhpGetFuncEvalMode();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static uint RhpRecordDebuggeeInitiatedHandle(void* objectHandle);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static void RhpVerifyDebuggerCleanup();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static global::System.IntPtr RhpGetCurrentThread();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void RhWaitForPendingFinalizers(int allowReentrantWait);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", EntryPoint="RhYield", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static int _RhYield();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static void RhFlushProcessWriteBuffers();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int RhCompatibleReentrantWaitAny(
					int alertable, 
					int timeout, 
					int count, 
					global::System.IntPtr* handles);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", EntryPoint="RhCallDescrWorker", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void RhCallDescrWorkerNative(global::System.IntPtr callDescr);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void _ecvt_s(
					byte* buffer, 
					int sizeInBytes, 
					double value, 
					int count, 
					int* dec, 
					int* sign);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void memmove(
					byte* dmem, 
					byte* smem, 
					ulong size);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void memset(
					byte* mem, 
					int value, 
					ulong size);
	}

	public unsafe static partial class __PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("*", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void CallingConventionConverter_GetStubs(
					global::System.IntPtr* returnVoidStub, 
					global::System.IntPtr* returnIntegerStub, 
					global::System.IntPtr* commonStub);
	}

	public unsafe static partial class api_ms_win_core_winrt_string_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-winrt-string-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int WindowsCreateStringReference(
					ushort* sourceString, 
					uint length, 
					global::System_Runtime_InteropServices.HSTRING_HEADER__System_Private_Interop* phstringHeader, 
					void* hstring);
	}

	public unsafe static partial class api_ms_win_core_errorhandling_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-errorhandling-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetLastError();

		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-errorhandling-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void SetLastError(uint dwErrCode);
	}

	public unsafe static partial class api_ms_win_core_winrt_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-winrt-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int RoInitialize(uint initType);
	}

	public unsafe static partial class api_ms_win_core_localization_l1_2_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int IsValidLocaleName(ushort* lpLocaleName);

		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int ResolveLocaleName(
					ushort* lpNameToResolve, 
					ushort* lpLocaleName, 
					int cchLocaleName);
	}

	public unsafe static partial class crypt32_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertDuplicateCertificateContext(global::System.IntPtr pCertContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetCertificateContextProperty(
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pvData, 
					int* pcbData);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptQueryObject(
					global::Internal_Cryptography_Pal_Native.CertQueryObjectType__System_Security_Cryptography_X509Certificates dwObjectType, 
					void* pvObject, 
					global::Internal_Cryptography_Pal_Native.ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedContentTypeFlags, 
					global::Internal_Cryptography_Pal_Native.ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedFormatTypeFlags, 
					int dwFlags, 
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates* pdwMsgAndCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.ContentType__System_Security_Cryptography_X509Certificates* pdwContentType, 
					global::Internal_Cryptography_Pal_Native.FormatType__System_Security_Cryptography_X509Certificates* pdwFormatType, 
					global::System.IntPtr* phCertStore, 
					global::System.IntPtr* phMsg, 
					global::System.IntPtr* ppvContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertDuplicateCertificateContext", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertDuplicateCertificateContextWithKeyContainerDeletion(global::System.IntPtr pCertContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertFreeCertificateContext(global::System.IntPtr pCertContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptMsgGetParam(
					global::System.IntPtr hCryptMsg, 
					global::Internal_Cryptography_Pal_Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					int* pvData, 
					int* pcbData);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CryptMsgGetParam", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptMsgGetParam__0(
					global::System.IntPtr hCryptMsg, 
					global::Internal_Cryptography_Pal_Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					byte* pvData, 
					int* pcbData);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr PFXImportCertStore(
					global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pPFX, 
					global::System.IntPtr password, 
					global::Internal_Cryptography_Pal_Native.PfxCertStoreFlags__System_Security_Cryptography_X509Certificates dwFlags);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CryptFindOIDInfo(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Encoding dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertGetCertificateContextProperty", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetCertificateContextProperty__0(
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					byte* pvData, 
					int* pcbData);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertCloseStore(
					global::System.IntPtr hCertStore, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptMsgClose(global::System.IntPtr hCryptMsg);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertFindCertificateInStore(
					global::System.IntPtr hCertStore, 
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CertFindFlags__System_Security_Cryptography_X509Certificates dwFindFlags, 
					global::Internal_Cryptography_Pal_Native.CertFindType__System_Security_Cryptography_X509Certificates dwFindType, 
					void* pvFindPara, 
					global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertEnumCertificatesInStore(
					global::System.IntPtr hCertStore, 
					global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertGetNameStringW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetNameString(
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertNameType__System_Security_Cryptography_X509Certificates dwType, 
					global::Internal_Cryptography_Pal_Native.CertNameFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::Internal_Cryptography_Pal_Native.CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates* pvPara, 
					ushort* pszNameString, 
					int cchNameString);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertGetNameStringW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetNameString__0(
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertNameType__System_Security_Cryptography_X509Certificates dwType, 
					global::Internal_Cryptography_Pal_Native.CertNameFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::Internal_Cryptography_Pal_Native.CertNameStringType__System_Security_Cryptography_X509Certificates* pvTypePara, 
					ushort* pszNameString, 
					int cchNameString);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CryptFindOIDInfo", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CryptFindOIDInfo__0(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_X509Certificates dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetCertificateChain(
					global::System.IntPtr hChainEngine, 
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates* pTime, 
					global::System.IntPtr hStore, 
					global::Internal_Cryptography_Pal_Native.CERT_CHAIN_PARA__System_Security_Cryptography_X509Certificates* pChainPara, 
					global::Internal_Cryptography_Pal_Native.CertChainFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::System.IntPtr pvReserved, 
					global::System.IntPtr* ppChainContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertVerifyCertificateChainPolicy(
					global::System.IntPtr pszPolicyOID, 
					global::System.IntPtr pChainContext, 
					global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_PARA__System_Security_Cryptography_X509Certificates* pPolicyPara, 
					global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_STATUS__System_Security_Cryptography_X509Certificates* pPolicyStatus);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertNameToStrW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertNameToStr(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pName, 
					global::Internal_Cryptography_Pal_Native.CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates dwStrType, 
					ushort* psz, 
					int csz);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptFormatObject(
					int dwCertEncodingType, 
					int dwFormatType, 
					int dwFormatStrType, 
					global::System.IntPtr pFormatStruct, 
					byte* lpszStructType, 
					byte* pbEncoded, 
					int cbEncoded, 
					ushort* pbFormat, 
					int* pcbFormat);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertControlStore(
					global::System.IntPtr hCertStore, 
					global::Internal_Cryptography_Pal_Native.CertControlStoreFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::Internal_Cryptography_Pal_Native.CertControlStoreType__System_Security_Cryptography_X509Certificates dwControlType, 
					global::System.IntPtr pvCtrlPara);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertAddCertificateLinkToStore(
					global::System.IntPtr hCertStore, 
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertStoreAddDisposition__System_Security_Cryptography_X509Certificates dwAddDisposition, 
					global::System.IntPtr ppStoreContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CryptFormatObject", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptFormatObject__0(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.FormatObjectType__System_Security_Cryptography_X509Certificates dwFormatType, 
					global::Internal_Cryptography_Pal_Native.FormatObjectStringType__System_Security_Cryptography_X509Certificates dwFormatStrType, 
					global::System.IntPtr pFormatStruct, 
					global::System.IntPtr lpszStructType, 
					byte* pbEncoded, 
					int cbEncoded, 
					ushort* pbFormat, 
					int* pcbFormat);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertOpenStore(
					global::System.IntPtr lpszStoreProvider, 
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwMsgAndCertEncodingType, 
					global::System.IntPtr hCryptProv, 
					global::Internal_Cryptography_Pal_Native.CertStoreFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					ushort* pvPara);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptImportPublicKeyInfoEx2(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CERT_PUBLIC_KEY_INFO__System_Security_Cryptography_X509Certificates* pInfo, 
					int dwFlags, 
					void* pvAuxInfo, 
					global::System.IntPtr* phKey);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptDecodeObject(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::System.IntPtr lpszStructType, 
					byte* pbEncoded, 
					int cbEncoded, 
					global::Internal_Cryptography_Pal_Native.CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					byte* pvStructInfo, 
					int* pcbStructInfo);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void CertFreeCertificateChain(global::System.IntPtr pChainContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates* CertFindExtension(
					byte* pszObjId, 
					int cExtensions, 
					global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates* rgExtensions);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetValidUsages(
					int cCerts, 
					global::System.IntPtr* rghCerts, 
					int* cNumOIDs, 
					void* rghOIDs, 
					int* pcbOIDs);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetIntendedKeyUsage(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates* pCertInfo, 
					global::System_Security_Cryptography_X509Certificates.X509KeyUsageFlags__System_Security_Cryptography_X509Certificates* pbKeyUsage, 
					int cbKeyUsage);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CryptDecodeObject", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptDecodeObjectPointer(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::System.IntPtr lpszStructType, 
					byte* pbEncoded, 
					int cbEncoded, 
					global::Internal_Cryptography_Pal_Native.CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					void* pvStructInfo, 
					int* pcbStructInfo);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertVerifyTimeValidity(
					global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates* pTimeToVerify, 
					global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates* pCertInfo);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CryptFindOIDInfo", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CryptFindOIDInfo__1(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Cng dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertVerifyCertificateChainPolicy", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertVerifyCertificateChainPolicy__0(
					global::System.IntPtr pszPolicyOID, 
					global::System.IntPtr pChainContext, 
					global::_.Interop_Crypt32_CERT_CHAIN_POLICY_PARA__System_Net_Security* pPolicyPara, 
					global::_.Interop_Crypt32_CERT_CHAIN_POLICY_STATUS__System_Net_Security* pPolicyStatus);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertEnumCertificatesInStore", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_Crypt32_CERT_CONTEXT__System_Net_Security* CertEnumCertificatesInStore__0(
					global::System.IntPtr hCertStore, 
					global::_.Interop_Crypt32_CERT_CONTEXT__System_Net_Security* pPrevCertContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertFreeCertificateContext", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertFreeCertificateContext__0(global::System.IntPtr pCertContext);
	}

	public unsafe static partial class kernel32_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetCPInfoExW(
					uint CodePage, 
					uint dwFlags, 
					global::_.Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages* lpCPInfoEx);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr LocalAlloc(
					int uFlags, 
					global::System.UIntPtr sizetdwBytes);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr LocalFree(global::System.IntPtr handle);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__0(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__1(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__2(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__3(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="LocalAlloc", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr LocalAlloc__0(
					int uFlags, 
					global::System.UIntPtr sizetdwBytes);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr GetCurrentThread();

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr GetCurrentProcess();

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CloseHandle(global::System.IntPtr handle);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="LocalFree", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr LocalFree__0(global::System.IntPtr handle);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CheckTokenMembershipEx(
					global::System.IntPtr TokenHandle, 
					byte* SidToCheck, 
					uint Flags, 
					int* IsMember);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int DuplicateHandle(
					global::System.IntPtr hSourceProcessHandle, 
					global::System.IntPtr hSourceHandle, 
					global::System.IntPtr hTargetProcessHandle, 
					global::System.IntPtr* lpTargetHandle, 
					uint dwDesiredAccess, 
					int bInheritHandle, 
					uint dwOptions);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int SetFileCompletionNotificationModes(
					global::System.IntPtr handle, 
					global::_.Interop_Kernel32_FileCompletionNotificationModes__System_Net_Sockets flags);
	}

	public unsafe static partial class api_ms_win_core_com_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-com-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CoCreateInstance(
					byte* rclsid, 
					global::System.IntPtr pUnkOuter, 
					int dwClsContext, 
					byte* riid, 
					global::System.IntPtr* ppv);
	}

	public unsafe static partial class advapi32_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptAcquireContextW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptAcquireContext(
					global::System.IntPtr* psafeProvHandle, 
					ushort* pszContainer, 
					ushort* pszProvider, 
					int dwProvType, 
					global::Internal_Cryptography_Pal_Native.CryptAcquireContextFlags__System_Security_Cryptography_X509Certificates dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptGetKeyParam(
					global::System.IntPtr safeKeyHandle, 
					int dwParam, 
					byte* pbData, 
					int* pdwDataLen, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptGetDefaultProviderW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptGetDefaultProvider(
					int dwProvType, 
					global::System.IntPtr pdwReserved, 
					int dwFlags, 
					ushort* pszProvName, 
					int* IntPtrProvName);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptAcquireContextW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptAcquireContext__0(
					global::System.IntPtr* psafeProvHandle, 
					ushort* pszContainer, 
					ushort* pszProvider, 
					int dwProvType, 
					uint dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptGetUserKey", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int _CryptGetUserKey(
					global::System.IntPtr safeProvHandle, 
					int dwKeySpec, 
					global::System.IntPtr* safeKeyHandle);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptGetProvParam(
					global::System.IntPtr safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					global::System.IntPtr pbData, 
					int* dwDataLen, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptDestroyKey(global::System.IntPtr hKey);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptReleaseContext(
					global::System.IntPtr safeProvHandle, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptImportKey", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int _CryptImportKey(
					global::System.IntPtr hProv, 
					byte* pbData, 
					int dwDataLen, 
					global::System.IntPtr hPubKey, 
					int dwFlags, 
					global::System.IntPtr* phKey);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptSetProvParam", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptSetProvParamIndirectPtr(
					global::System.IntPtr safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					global::System.IntPtr* pbData, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptSetProvParam(
					global::System.IntPtr safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					global::System.IntPtr pbData, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptGenKey", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int _CryptGenKey(
					global::System.IntPtr safeProvHandle, 
					int Algid, 
					int dwFlags, 
					global::System.IntPtr* safeKeyHandle);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int RevertToSelf();

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int ImpersonateLoggedOnUser(global::System.IntPtr userToken);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetTokenInformation(
					global::System.IntPtr TokenHandle, 
					uint TokenInformationClass, 
					global::System.IntPtr TokenInformation, 
					uint TokenInformationLength, 
					uint* ReturnLength);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int OpenThreadToken(
					global::System.IntPtr ThreadHandle, 
					global::System_Security_Principal.TokenAccessLevels__System_Security_Principal_Windows dwDesiredAccess, 
					int bOpenAsSelf, 
					global::System.IntPtr* phThreadToken);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int OpenProcessToken(
					global::System.IntPtr ProcessToken, 
					global::System_Security_Principal.TokenAccessLevels__System_Security_Principal_Windows DesiredAccess, 
					global::System.IntPtr* TokenHandle);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint LsaNtStatusToWinError(uint status);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int DuplicateTokenEx(
					global::System.IntPtr hExistingToken, 
					uint dwDesiredAccess, 
					global::System.IntPtr lpTokenAttributes, 
					uint ImpersonationLevel, 
					uint TokenType, 
					global::System.IntPtr* phNewToken);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="GetTokenInformation", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetTokenInformation__0(
					global::System.IntPtr TokenHandle, 
					uint TokenInformationClass, 
					global::System.IntPtr TokenInformation, 
					uint TokenInformationLength, 
					uint* ReturnLength);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint LsaLookupSids(
					global::System.IntPtr handle, 
					int count, 
					global::System.IntPtr* sids, 
					global::System.IntPtr* referencedDomains, 
					global::System.IntPtr* names);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint LsaLookupNames2(
					global::System.IntPtr handle, 
					int flags, 
					int count, 
					global::_.Interop_UNICODE_STRING__System_Security_Principal_Windows__Impl.UnsafeType* names, 
					global::System.IntPtr* referencedDomains, 
					global::System.IntPtr* sids);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint LsaOpenPolicy(
					ushort* systemName, 
					global::_.Interop_LSA_OBJECT_ATTRIBUTES__System_Security_Principal_Windows* attributes, 
					int accessMask, 
					global::System.IntPtr* handle);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int LsaClose(global::System.IntPtr handle);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int LsaFreeMemory(global::System.IntPtr handle);
	}

	public unsafe static partial class ws2_32_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int WSAGetOverlappedResult(
					global::System.IntPtr socketHandle, 
					global::System_Threading.NativeOverlapped__System_Private_CoreLib* overlapped, 
					uint* bytesTransferred, 
					int wait, 
					global::System_Net_Sockets.SocketFlags__System_Net_Sockets* socketFlags);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::System.IntPtr* pointer, 
					int optionLength);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="setsockopt", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt__0(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					byte* optionValue, 
					int optionLength);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives getsockname(
					global::System.IntPtr socketHandle, 
					byte* socketAddress, 
					int* socketAddressSize);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives getpeername(
					global::System.IntPtr socketHandle, 
					byte* socketAddress, 
					int* socketAddressSize);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives WSAStartup(
					short wVersionRequested, 
					global::_.Interop_Winsock_WSAData__System_Net_NameResolution__Impl.UnsafeType* lpWSAData);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int select(
					int ignoredParameter, 
					global::System.IntPtr* readfds, 
					global::System.IntPtr* writefds, 
					global::System.IntPtr* exceptfds, 
					global::_.Interop_Winsock_TimeValue__System_Net_Sockets* timeout);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="select", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int select__0(
					int ignoredParameter, 
					global::System.IntPtr* readfds, 
					global::System.IntPtr* writefds, 
					global::System.IntPtr* exceptfds, 
					global::System.IntPtr nullTimeout);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives ioctlsocket(
					global::System.IntPtr socketHandle, 
					int cmd, 
					int* argp);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives shutdown(
					global::System.IntPtr socketHandle, 
					int how);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="setsockopt", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt__1(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					int* optionValue, 
					int optionLength);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int recv(
					global::System.IntPtr socketHandle, 
					byte* pinnedBuffer, 
					int len, 
					global::System_Net_Sockets.SocketFlags__System_Net_Sockets socketFlags);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives WSAIoctl(
					global::System.IntPtr socketHandle, 
					int ioControlCode, 
					global::System.Guid* guid, 
					int guidSize, 
					global::System.IntPtr* funcPtr, 
					int funcPtrSize, 
					int* bytesTransferred, 
					global::System.IntPtr shouldBeNull, 
					global::System.IntPtr shouldBeNull2);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetAddrInfoW(
					ushort* nodename, 
					ushort* servicename, 
					global::System_Net_Sockets.AddressInfo__System_Net_NameResolution* hints, 
					global::System.IntPtr* handle);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr WSASocketW(
					global::System_Net_Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System_Net_Sockets.SocketType__System_Net_Sockets socketType, 
					int protocolType, 
					global::System.IntPtr protocolInfo, 
					int group, 
					int flags);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives closesocket(global::System.IntPtr socketHandle);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="WSASocketW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr WSASocketW__0(
					global::System_Net_Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System_Net_Sockets.SocketType__System_Net_Sockets socketType, 
					global::System_Net_Sockets.ProtocolType__System_Net_Sockets protocolType, 
					global::System.IntPtr protocolInfo, 
					uint group, 
					global::_.Interop_Winsock_SocketConstructorFlags__System_Net_Sockets flags);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives WSAConnect(
					global::System.IntPtr socketHandle, 
					byte* socketAddress, 
					int socketAddressSize, 
					global::System.IntPtr inBuffer, 
					global::System.IntPtr outBuffer, 
					global::System.IntPtr sQOS, 
					global::System.IntPtr gQOS);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives listen(
					global::System.IntPtr socketHandle, 
					int backlog);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives bind(
					global::System.IntPtr socketHandle, 
					byte* socketAddress, 
					int socketAddressSize);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives getsockopt(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					int* optionValue, 
					int* optionLength);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int send(
					global::System.IntPtr socketHandle, 
					byte* pinnedBuffer, 
					int len, 
					global::System_Net_Sockets.SocketFlags__System_Net_Sockets socketFlags);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void freeaddrinfo(global::System.IntPtr info);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void FreeAddrInfoExW(global::System_Net_Sockets.AddressInfoEx__System_Net_NameResolution* pAddrInfo);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="WSASocketW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr WSASocketW__1(
					global::System_Net_Sockets.AddressFamily__System_Net_Primitives addressFamily, 
					global::System_Net_Internals.SocketType__System_Net_NameResolution socketType, 
					int protocolType, 
					global::System.IntPtr protocolInfo, 
					int group, 
					int flags);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="closesocket", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives closesocket__0(global::System.IntPtr socketHandle);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives gethostname(
					byte* hostName, 
					int bufferLength);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="getsockopt", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives getsockopt__0(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::_.Interop_Winsock_Linger__System_Net_Sockets* optionValue, 
					int* optionLength);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="getsockopt", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives getsockopt__1(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::_.Interop_Winsock_IPMulticastRequest__System_Net_Sockets* optionValue, 
					int* optionLength);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="getsockopt", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives getsockopt__2(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::_.Interop_Winsock_IPv6MulticastRequest__System_Net_Sockets__Impl.UnsafeType* optionValue, 
					int* optionLength);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="ioctlsocket", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives ioctlsocket__0(
					global::System.IntPtr handle, 
					int cmd, 
					int* argp);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="setsockopt", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt__2(
					global::System.IntPtr handle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::_.Interop_Winsock_Linger__System_Net_Sockets* linger, 
					int optionLength);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr accept(
					global::System.IntPtr socketHandle, 
					byte* socketAddress, 
					int* socketAddressSize);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetAddrInfoExW(
					ushort* pName, 
					ushort* pServiceName, 
					int dwNamespace, 
					global::System.IntPtr lpNspId, 
					global::System_Net_Sockets.AddressInfoEx__System_Net_NameResolution* pHints, 
					global::System_Net_Sockets.AddressInfoEx__System_Net_NameResolution** ppResult, 
					global::System.IntPtr timeout, 
					global::System_Threading.NativeOverlapped__System_Private_CoreLib* lpOverlapped, 
					void* lpCompletionRoutine, 
					global::System.IntPtr* lpNameHandle);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives WSARecv(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.WSABuffer__System_Net_Sockets* buffer, 
					int bufferCount, 
					int* bytesTransferred, 
					global::System_Net_Sockets.SocketFlags__System_Net_Sockets* socketFlags, 
					global::System_Threading.NativeOverlapped__System_Private_CoreLib* overlapped, 
					global::System.IntPtr completionRoutine);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives WSASend(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.WSABuffer__System_Net_Sockets* buffers, 
					int bufferCount, 
					int* bytesTransferred, 
					global::System_Net_Sockets.SocketFlags__System_Net_Sockets socketFlags, 
					global::System_Threading.NativeOverlapped__System_Private_CoreLib* overlapped, 
					global::System.IntPtr completionRoutine);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives GetNameInfoW(
					byte* sa, 
					int salen, 
					ushort* host, 
					int hostlen, 
					ushort* serv, 
					int servlen, 
					int flags);
	}

	public unsafe static partial class OleAut32_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("OleAut32", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void SysFreeString(global::System.IntPtr bstr);
	}

	public unsafe static partial class ncrypt_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenKey(
					global::System.IntPtr hProvider, 
					global::System.IntPtr* phKey, 
					ushort* pszKeyName, 
					int dwLegacyKeySpec, 
					global::System_Security_Cryptography.CngKeyOpenOptions__System_Security_Cryptography_Cng dwFlags);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptDeleteKey(
					global::System.IntPtr hKey, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenStorageProvider(
					global::System.IntPtr* phProvider, 
					ushort* pszProviderName, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptFreeObject(global::System.IntPtr hObject);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptImportKey(
					global::System.IntPtr hProvider, 
					global::System.IntPtr hImportKey, 
					ushort* pszBlobType, 
					global::System.IntPtr pParameterList, 
					global::System.IntPtr* phKey, 
					byte* pbData, 
					int cbData, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptGetProperty(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					global::System_Security_Cryptography.CngPropertyOptions__System_Security_Cryptography_Cng dwFlags);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptSetProperty(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					void* pbInput, 
					int cbInput, 
					global::System_Security_Cryptography.CngPropertyOptions__System_Security_Cryptography_Cng dwFlags);
	}

	public unsafe static partial class api_ms_win_core_winrt_robuffer_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-winrt-robuffer-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.StdCall)]
		public extern static int RoGetBufferMarshaler(void** bufferMarshalerPtr);
	}

	public unsafe static partial class iphlpapi_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("iphlpapi.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint GetNetworkParams(
					global::System.IntPtr pFixedInfo, 
					uint* pOutBufLen);
	}

	public unsafe static partial class BCrypt_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptExportKey(
					global::System.IntPtr hKey, 
					global::System.IntPtr hExportKey, 
					ushort* pszBlobType, 
					byte* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptGetProperty(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptDestroyKey(global::System.IntPtr hKey);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptCreateHash(
					global::System.IntPtr hAlgorithm, 
					global::System.IntPtr* phHash, 
					global::System.IntPtr pbHashObject, 
					int cbHashObject, 
					byte* pbSecret, 
					int cbSecret, 
					global::_.Interop_BCrypt_BCryptCreateHashFlags__System_Security_Cryptography_Algorithms dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", EntryPoint="BCryptGetProperty", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptGetProperty__0(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptOpenAlgorithmProvider(
					global::System.IntPtr* phAlgorithm, 
					ushort* pszAlgId, 
					ushort* pszImplementation, 
					global::_.Interop_BCrypt_BCryptOpenAlgorithmProviderFlags__System_Security_Cryptography_Algorithms dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptCloseAlgorithmProvider(
					global::System.IntPtr hAlgorithm, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptDestroyHash(global::System.IntPtr hHash);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptGenRandom(
					global::System.IntPtr hAlgorithm, 
					byte* pbBuffer, 
					int cbBuffer, 
					int dwFlags);
	}

	public unsafe static partial class sspicli_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int LsaGetLogonSessionData(
					global::_.Interop_LUID__System_Security_Principal_Windows* LogonId, 
					global::System.IntPtr* ppLogonSessionData);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int LsaFreeReturnBuffer(global::System.IntPtr handle);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int EncryptMessage(
					global::_.Interop_SspiCli_CredHandle__System_Net_Security* contextHandle, 
					uint qualityOfProtection, 
					global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* inputOutput, 
					uint sequenceNumber);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int DecryptMessage(
					global::_.Interop_SspiCli_CredHandle__System_Net_Security* contextHandle, 
					global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* inputOutput, 
					uint sequenceNumber, 
					uint* qualityOfProtection);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int EnumerateSecurityPackagesW(
					int* pkgnum, 
					global::System.IntPtr* handle);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int QueryContextAttributesW(
					global::_.Interop_SspiCli_CredHandle__System_Net_Security* contextHandle, 
					global::_.Interop_SspiCli_ContextAttribute__System_Net_Security attribute, 
					void* buffer);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int ApplyControlToken(
					void* inContextPtr, 
					global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* inputBuffers);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FreeContextBuffer(global::System.IntPtr contextBuffer);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int AcceptSecurityContext(
					global::_.Interop_SspiCli_CredHandle__System_Net_Security* credentialHandle, 
					void* inContextPtr, 
					global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* inputBuffer, 
					global::_.Interop_SspiCli_ContextFlags__System_Net_Security inFlags, 
					global::_.Interop_SspiCli_Endianness__System_Net_Security endianness, 
					global::_.Interop_SspiCli_CredHandle__System_Net_Security* outContextPtr, 
					global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* outputBuffer, 
					global::_.Interop_SspiCli_ContextFlags__System_Net_Security* attributes, 
					long* timeStamp);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int DeleteSecurityContext(global::_.Interop_SspiCli_CredHandle__System_Net_Security* handlePtr);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int InitializeSecurityContextW(
					global::_.Interop_SspiCli_CredHandle__System_Net_Security* credentialHandle, 
					void* inContextPtr, 
					byte* targetName, 
					global::_.Interop_SspiCli_ContextFlags__System_Net_Security inFlags, 
					int reservedI, 
					global::_.Interop_SspiCli_Endianness__System_Net_Security endianness, 
					global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* inputBuffer, 
					int reservedII, 
					global::_.Interop_SspiCli_CredHandle__System_Net_Security* outContextPtr, 
					global::_.Interop_SspiCli_SecBufferDesc__System_Net_Security* outputBuffer, 
					global::_.Interop_SspiCli_ContextFlags__System_Net_Security* attributes, 
					long* timeStamp);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int AcquireCredentialsHandleW(
					ushort* principal, 
					ushort* moduleName, 
					int usage, 
					void* logonID, 
					global::_.Interop_SspiCli_SCHANNEL_CRED__System_Net_Security* authData, 
					void* keyCallback, 
					void* keyArgument, 
					global::_.Interop_SspiCli_CredHandle__System_Net_Security* handlePtr, 
					long* timeStamp);

		[global::System.Runtime.InteropServices.DllImport("sspicli.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FreeCredentialsHandle(global::_.Interop_SspiCli_CredHandle__System_Net_Security* handlePtr);
	}
}

